{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Robo Appian","text":""},{"location":"#overview","title":"Overview","text":"<p>Robo Appian simplifies Appian UI test automation by providing label-driven, readable APIs built on Selenium WebDriver. Tests use visible labels instead of brittle XPath selectors or IDs, making automation more stable and maintainable.</p> <p>Key benefits:</p> <ul> <li>\u2705 Label-first selectors - Locate elements by visible labels, not internal IDs</li> <li>\u2705 Resilient interactions - Smart waits and retry logic handle Appian's dynamic DOM</li> <li>\u2705 Clean API - Wait-first pattern keeps code consistent and readable</li> <li>\u2705 Comprehensive coverage - All major Appian UI components supported</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>Python 3.12+ - Modern Python with latest features</li> <li>Selenium 4.34+ - Latest WebDriver capabilities</li> <li>Poetry - Dependency management and packaging</li> <li>pytest - Recommended testing framework</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Start fast: Installation \u00b7 Quick Start</li> <li>How it works: Component patterns \u00b7 Best practices</li> <li>API docs: Component APIs</li> <li>Examples: Login \u00b7 Forms \u00b7 Tables \u00b7 Workflows</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 - Free to use, modify, and distribute.</p> <p>Copyright \u00a9 2024 Dinil Mithra</p>"},{"location":"#version-history","title":"Version History","text":"<p>Current version: 0.0.35</p> <p>Check the release notes for updates and improvements.</p> <p>Ready to script? Jump to the Quick Start.</p>"},{"location":"about/","title":"About the Author","text":"<p>Dinil Mithra is a Senior Consultant with deep expertise in application development and solution architecture, spanning opensource technologies and Oracle Fusion Middleware. Passionate about quality assurance and continuous improvement, Dinil recognized a critical gap in Appian UI automation tooling and developed Robo Appian to empower teams to:</p> <ul> <li>Write more reliable automated tests</li> <li>Reduce maintenance overhead</li> <li>Improve test readability and collaboration</li> <li>Accelerate delivery timelines</li> </ul> <p>Connect with Dinil:</p> <ul> <li>\ud83d\udd17 LinkedIn</li> <li>\ud83d\udce7 Email</li> </ul>"},{"location":"about/#contributing","title":"Contributing","text":"<p>Robo Appian is open source and welcomes contributions! Whether you're:</p> <ul> <li>Reporting a bug</li> <li>Suggesting a new feature</li> <li>Improving documentation</li> <li>Submitting code changes</li> </ul> <p>Your contributions help make this library better for the entire Appian automation community.</p> <p>Built with \u2764\ufe0f for the Appian testing community</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for all robo_appian utilities and components. All methods follow the wait-first pattern: pass <code>WebDriverWait</code> as the first argument.</p>"},{"location":"api/#component-utilities","title":"Component Utilities","text":"<p>Located under <code>robo_appian.components</code>, these utilities handle interaction with specific Appian UI elements:</p> <ul> <li>Buttons - Click buttons and action links by label</li> <li>Inputs - Fill text inputs by label or placeholder</li> <li>Dates - Set date values in date pickers</li> <li>Dropdowns - Select from standard dropdowns</li> <li>Search Dropdowns - Select from filterable dropdowns</li> <li>Search Inputs - Interact with searchable input fields</li> <li>Tables - Find rows, click cells, read table data</li> <li>Tabs - Switch between tab panels</li> <li>Links - Click links by visible text</li> <li>Labels - Find and verify label text</li> </ul>"},{"location":"api/#shared-utilities","title":"Shared Utilities","text":"<p>Located under <code>robo_appian.utils</code>, these provide low-level helpers:</p> <ul> <li>ComponentUtils - Element waiting, safe clicking, XPath queries</li> <li>RoboUtils - Retry logic, resilience helpers</li> <li>BrowserUtils - Multi-tab/window management</li> </ul>"},{"location":"api/#quick-examples","title":"Quick Examples","text":""},{"location":"api/#set-form-values","title":"Set form values","text":"<pre><code>from robo_appian.components import InputUtils, DateUtils, DropdownUtils\n\nInputUtils.setValueByLabelText(wait, \"Name\", \"John Doe\")\nDateUtils.setValueByLabelText(wait, \"Start Date\", \"01/15/2025\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Status\", \"Active\")\n</code></pre>"},{"location":"api/#interact-with-tables","title":"Interact with tables","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils\n\ntable = TableUtils.findTableByColumnName(wait, \"ID\")\nTableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, 0, \"ID\")\nbutton = TableUtils.findComponentFromTableCell(wait, 0, \"Actions\")\nButtonUtils.clickByLabelText(wait, \"Edit\")\n</code></pre>"},{"location":"api/#handle-retries","title":"Handle retries","text":"<pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components import ButtonUtils\n\nRoboUtils.retry_on_timeout(\n    lambda: ButtonUtils.clickByLabelText(wait, \"Submit\"),\n    max_retries=3,\n    operation_name=\"click submit\"\n)\n</code></pre> <p>See the Components guide for detailed usage patterns and best practices.</p>"},{"location":"api/browser-utils/","title":"Browser Utils","text":""},{"location":"api/browser-utils/#overview","title":"Overview","text":"<p>BrowserUtils provides tab and window management for multi-tab browser workflows. Switch between tabs, navigate to new tabs, and close tabs programmatically.</p> <p>Use these utilities when your Appian automation requires opening links in new tabs, managing multiple browser windows, or handling popup windows.</p>"},{"location":"api/browser-utils/#methods","title":"Methods","text":""},{"location":"api/browser-utils/#switch_to_tab","title":"switch_to_Tab","text":"<p>Switch to a specific browser tab by its index.</p> <p>Use this when you know which tab you need (e.g., after opening a link in a new tab). Tab indices are zero-based: 0 is the first tab, 1 is the second, etc.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>tab_number</code> (int): Zero-based index of the tab to switch to</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Raises:</p> <ul> <li><code>IndexError</code>: If tab_number is out of range for available tabs</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Link that opens in new tab --&gt;\n&lt;a href=\"/report\" target=\"_blank\"&gt;View Report&lt;/a&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components.LinkUtils import LinkUtils\n\n# Click link that opens new tab\nLinkUtils.click(wait, \"View Report\")\n\n# Switch to the new tab (second tab = index 1)\nBrowserUtils.switch_to_Tab(wait, 1)\n\n# Now interact with content in the new tab\n# ...\n\n# Switch back to first tab\nBrowserUtils.switch_to_Tab(wait, 0)\n</code></pre></p>"},{"location":"api/browser-utils/#switch_to_next_tab","title":"switch_to_next_tab","text":"<p>Switch to the next browser tab in sequence.</p> <p>Use this to cycle through tabs when you don't know the exact index. If already on the last tab, wraps around to the first tab.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Examples:</p> <p>Python: <pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\n\n# Cycle through all open tabs\nBrowserUtils.switch_to_next_tab(wait)  # Move to next tab\nBrowserUtils.switch_to_next_tab(wait)  # Move to next tab again\n\n# Process content in each tab\n</code></pre></p> <p>Example - Processing Multiple Report Tabs:</p> <pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components.LinkUtils import LinkUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Open multiple reports in new tabs\nLinkUtils.click(wait, \"Sales Report\")\nLinkUtils.click(wait, \"Inventory Report\")\nLinkUtils.click(wait, \"Finance Report\")\n\n# Get initial tab count\ninitial_tabs = len(wait._driver.window_handles)\n\n# Process each report tab\nfor _ in range(initial_tabs):\n    # Do something in current tab\n    print(f\"Processing: {wait._driver.title}\")\n\n    # Move to next tab\n    BrowserUtils.switch_to_next_tab(wait)\n</code></pre>"},{"location":"api/browser-utils/#close_current_tab_and_switch_back","title":"close_current_tab_and_switch_back","text":"<p>Close the current browser tab and return to the previous tab.</p> <p>Use this after completing work in a new tab and wanting to return to your original workflow. Automatically calculates and switches to the previous tab index.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;a href=\"/details\" target=\"_blank\"&gt;View Details&lt;/a&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components import LinkUtils, LabelUtils\n\n# Open details in new tab\nLinkUtils.click(wait, \"View Details\")\nBrowserUtils.switch_to_Tab(wait, 1)\n\n# Read information from details page\nLabelUtils.isLabelExists(wait, \"Record Details\")\n# ... extract data ...\n\n# Close details tab and return to main page\nBrowserUtils.close_current_tab_and_switch_back(wait)\n\n# Continue working in original tab\n</code></pre></p>"},{"location":"api/browser-utils/#common-workflows","title":"Common Workflows","text":""},{"location":"api/browser-utils/#opening-and-processing-a-new-tab","title":"Opening and Processing a New Tab","text":"<pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components import ButtonUtils, InputUtils\n\n# Click button that opens new tab\nButtonUtils.clickByLabelText(wait, \"Open Form\")\n\n# Switch to new tab\nBrowserUtils.switch_to_Tab(wait, 1)\n\n# Fill form in new tab\nInputUtils.setValueByLabelText(wait, \"Name\", \"John Doe\")\nButtonUtils.clickByLabelText(wait, \"Submit\")\n\n# Close new tab and return\nBrowserUtils.close_current_tab_and_switch_back(wait)\n</code></pre>"},{"location":"api/browser-utils/#handling-multiple-report-tabs","title":"Handling Multiple Report Tabs","text":"<pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components.TableUtils import TableUtils\n\n# Assume multiple report tabs are already open\ntab_count = len(wait._driver.window_handles)\n\nresults = []\nfor tab_index in range(tab_count):\n    BrowserUtils.switch_to_Tab(wait, tab_index)\n\n    # Extract data from each tab\n    table = TableUtils.findTableByColumnName(wait, \"Amount\")\n    row_count = TableUtils.rowCount(table)\n\n    results.append({\n        'tab': tab_index,\n        'title': wait._driver.title,\n        'rows': row_count\n    })\n\nprint(results)\n</code></pre>"},{"location":"api/browser-utils/#verifying-new-tab-contents","title":"Verifying New Tab Contents","text":"<pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\nfrom robo_appian.components import LinkUtils, LabelUtils\n\n# Click link\nLinkUtils.click(wait, \"User Guide\")\n\n# Switch to new tab\nBrowserUtils.switch_to_Tab(wait, 1)\n\n# Verify expected content loaded\nLabelUtils.isLabelExists(wait, \"Getting Started\")\n\n# Close and return\nBrowserUtils.close_current_tab_and_switch_back(wait)\n</code></pre>"},{"location":"api/browser-utils/#cycling-through-all-tabs","title":"Cycling Through All Tabs","text":"<pre><code>from robo_appian.utils.BrowserUtils import BrowserUtils\n\n# Process each tab in order\nnum_tabs = len(wait._driver.window_handles)\n\nfor i in range(num_tabs):\n    print(f\"Tab {i}: {wait._driver.title}\")\n\n    # Do work in this tab\n    # ...\n\n    # Move to next tab (wraps around at end)\n    BrowserUtils.switch_to_next_tab(wait)\n</code></pre>"},{"location":"api/browser-utils/#best-practices","title":"Best Practices","text":""},{"location":"api/browser-utils/#track-tab-count","title":"Track Tab Count","text":"<p>Always check how many tabs are open before switching:</p> <pre><code>tab_count = len(wait._driver.window_handles)\nif tab_count &gt; 1:\n    BrowserUtils.switch_to_Tab(wait, 1)\n</code></pre>"},{"location":"api/browser-utils/#handle-tab-closure-gracefully","title":"Handle Tab Closure Gracefully","text":"<p>When closing tabs, ensure you're not closing the last tab:</p> <pre><code>if len(wait._driver.window_handles) &gt; 1:\n    BrowserUtils.close_current_tab_and_switch_back(wait)\n</code></pre>"},{"location":"api/browser-utils/#wait-after-tab-switch","title":"Wait After Tab Switch","text":"<p>Give the browser time to switch context:</p> <pre><code>from robo_appian.components.LabelUtils import LabelUtils\n\nBrowserUtils.switch_to_Tab(wait, 1)\n\n# Wait for content to confirm tab loaded\nLabelUtils.isLabelExists(wait, \"Expected Page Title\")\n</code></pre>"},{"location":"api/browser-utils/#clean-up-tabs-in-test-teardown","title":"Clean Up Tabs in Test Teardown","text":"<p>Close extra tabs at the end of tests:</p> <pre><code>def teardown():\n    # Close all tabs except the first\n    while len(wait._driver.window_handles) &gt; 1:\n        BrowserUtils.switch_to_Tab(wait, 1)\n        wait._driver.close()\n\n    # Return to first tab\n    BrowserUtils.switch_to_Tab(wait, 0)\n</code></pre>"},{"location":"api/button-utils/","title":"Button Utils","text":""},{"location":"api/button-utils/#overview","title":"Overview","text":"<p>ButtonUtils provides reliable button interactions using visible text labels. Buttons can be located by exact label match, partial text match, or HTML id attributes.</p> <p>All click operations handle animations, overlays, and other timing issues automatically to ensure reliable interaction.</p>"},{"location":"api/button-utils/#methods","title":"Methods","text":""},{"location":"api/button-utils/#clickbylabeltext","title":"clickByLabelText","text":"<p>Click a button by its exact label text (full match).</p> <p>Use this when you know the complete, exact text displayed on the button. This is the most precise way to interact with buttons and works best when button labels are stable and consistent across your application.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Exact button label text to match</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If button not found or not clickable within wait timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Submit&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\n# Click button with exact label \"Submit\"\nButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre></p>"},{"location":"api/button-utils/#clickbypartiallabeltext","title":"clickByPartialLabelText","text":"<p>Click a button by partial label match.</p> <p>Use this when you only know part of the button text, or when button labels include dynamic content like counts or dates. Perfect for situations where the full label might change but a key word remains constant (e.g., \"Submit\" appears in \"Submit Form\", \"Submit Application\", etc.).</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Partial button label text</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If button not found or not clickable within wait timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Submit Form&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\n# Matches \"Submit\", \"Submit Form\", \"Form Submit\", etc.\nButtonUtils.clickByPartialLabelText(wait, \"Submit\")\n</code></pre></p>"},{"location":"api/button-utils/#clickbyid","title":"clickById","text":"<p>Click a button by its HTML id attribute.</p> <p>Use this when the button has a specific HTML id and label-based selection isn't suitable. This is useful for buttons without visible text labels or when you need to target a specific button among several with similar labels.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>id</code> (str): The HTML id attribute of the button element</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If button not found or not clickable within wait timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button id=\"save_button\"&gt;\n  &lt;span&gt;Save&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\nButtonUtils.clickById(wait, \"save_button\")\n</code></pre></p>"},{"location":"api/button-utils/#isbuttonexistsbylabeltext","title":"isButtonExistsByLabelText","text":"<p>Check if a button exists by exact label match.</p> <p>Use this to verify a button is present on the page before attempting to click it. This method won't throw an error if the button is missing - it simply returns False. Perfect for conditional logic where button availability might vary based on user permissions or page state.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Exact button label text to match</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if button found, False otherwise</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Submit&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\nif ButtonUtils.isButtonExistsByLabelText(wait, \"Submit\"):\n    ButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre></p>"},{"location":"api/button-utils/#isbuttonexistsbypartiallabeltext","title":"isButtonExistsByPartialLabelText","text":"<p>Check if a button exists by partial label match.</p> <p>Use this to verify a button containing specific text is present on the page. Like the exact match version, this returns a boolean without throwing errors. Useful when you need to check for buttons with dynamic or variable labels in conditional workflows.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Partial button label text to match</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if button found, False otherwise</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Save Changes&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\nif ButtonUtils.isButtonExistsByPartialLabelText(wait, \"Save\"):\n    ButtonUtils.clickByPartialLabelText(wait, \"Save\")\n</code></pre></p>"},{"location":"api/button-utils/#isbuttonexistsbypartiallabeltextafterload","title":"isButtonExistsByPartialLabelTextAfterLoad","text":"<p>Check if a button exists after page load by partial label match.</p> <p>Use this when you need to verify a button appears after a page refresh, navigation, or asynchronous content load. This method waits for the page to complete loading before checking for the button, making it ideal for testing workflows that involve page transitions or dynamic UI updates.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Partial button label text to match</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if button found after page load, False otherwise</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Continue to Next Step&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\nif ButtonUtils.isButtonExistsByPartialLabelTextAfterLoad(wait, \"Continue\"):\n    ButtonUtils.clickByPartialLabelText(wait, \"Continue\")\n</code></pre></p>"},{"location":"api/button-utils/#waitforbuttontobevisiblebypartiallabeltext","title":"waitForButtonToBeVisibleByPartialLabelText","text":"<p>Wait for a button to become visible by partial label match.</p> <p>Use this when you need to wait for a button to appear on the page before proceeding. This is essential for handling dynamically loaded content or buttons that appear after asynchronous operations complete. The method blocks execution until the button is visible or the timeout is reached.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Partial button label text to match</li> </ul> <p>Returns:</p> <ul> <li><code>WebElement</code>: The visible button element</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If button not visible within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button&gt;\n  &lt;span&gt;Submit Application&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.ButtonUtils import ButtonUtils\n\nButtonUtils.waitForButtonToBeVisibleByPartialLabelText(wait, \"Submit\")\nButtonUtils.clickByPartialLabelText(wait, \"Submit\")\n</code></pre></p>"},{"location":"api/component-driver/","title":"Component Driver","text":"<p>This page has been removed. Please use the individual component utilities directly:</p> <ul> <li>Buttons</li> <li>Inputs</li> <li>Dates</li> <li>Dropdowns</li> <li>Search Dropdowns</li> <li>Search Inputs</li> <li>Tables</li> <li>Tabs</li> <li>Labels</li> <li>Links</li> </ul>"},{"location":"api/component-utils/","title":"Component Utils","text":""},{"location":"api/component-utils/#overview","title":"Overview","text":"<p>ComponentUtils provides foundational capabilities for interacting with web elements. These low-level utilities handle element waiting, clicking, visibility checks, and date formatting.</p> <p>Most robo_appian components use ComponentUtils internally. You can also use these methods directly for custom interactions not covered by higher-level utilities.</p>"},{"location":"api/component-utils/#methods","title":"Methods","text":""},{"location":"api/component-utils/#click","title":"click","text":"<p>Reliably click an element using ActionChains with automatic waiting.</p> <p>Use this instead of <code>element.click()</code> for more reliable clicks that handle animations, overlays, and timing issues. This method waits for the element to be clickable, moves the mouse to it, and performs a safe click.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>component</code> (WebElement): The element to click</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not clickable within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button id=\"save_btn\"&gt;\n  &lt;span&gt;Save&lt;/span&gt;\n&lt;/button&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\nfrom selenium.webdriver.common.by import By\n\n# Find element and click safely\nbutton = driver.find_element(By.ID, \"save_btn\")\nComponentUtils.click(wait, button)\n</code></pre></p>"},{"location":"api/component-utils/#waitforcomponenttobevisiblebyxpath","title":"waitForComponentToBeVisibleByXpath","text":"<p>Wait for an element to become visible and return it.</p> <p>Use this when you need to find an element by XPath and ensure it's both present in the DOM and visible to users before proceeding. This is used internally by most robo_appian utilities.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>xpath</code> (str): XPath expression to locate the element</li> </ul> <p>Returns:</p> <ul> <li><code>WebElement</code>: The element once it becomes visible</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not visible within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div id=\"status\"&gt;\n  &lt;span&gt;Loading complete&lt;/span&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for status message\nelement = ComponentUtils.waitForComponentToBeVisibleByXpath(\n    wait, \n    \"//span[text()='Loading complete']\"\n)\nprint(element.text)  # \"Loading complete\"\n</code></pre></p>"},{"location":"api/component-utils/#waitforcomponentnottobevisiblebyxpath","title":"waitForComponentNotToBeVisibleByXpath","text":"<p>Wait until an element is no longer visible.</p> <p>Use this when you need to verify an element has disappeared, such as waiting for a loading spinner to finish or a modal dialog to close.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>xpath</code> (str): XPath expression to locate the element</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if element became invisible before timeout</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element still visible after timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Initially visible, then hidden --&gt;\n&lt;div class=\"spinner\"&gt;Loading...&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for loading spinner to disappear\nComponentUtils.waitForComponentNotToBeVisibleByXpath(\n    wait, \n    \"//div[@class='spinner']\"\n)\n# Continue with next action after spinner is gone\n</code></pre></p>"},{"location":"api/component-utils/#waitforelementtobevisiblebyid","title":"waitForElementToBeVisibleById","text":"<p>Wait for an element with a specific ID to become visible.</p> <p>Use this when elements have unique HTML id attributes. Simpler than XPath for straightforward element identification.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>id</code> (str): The HTML id attribute value</li> </ul> <p>Returns:</p> <ul> <li><code>WebElement</code>: The element once visible</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not visible within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div id=\"success_message\"&gt;\n  Form submitted successfully\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for success message by ID\nelement = ComponentUtils.waitForElementToBeVisibleById(wait, \"success_message\")\nprint(element.text)\n</code></pre></p>"},{"location":"api/component-utils/#waitforelementnottobevisiblebyid","title":"waitForElementNotToBeVisibleById","text":"<p>Wait until an element with a specific ID is no longer visible.</p> <p>Use this to verify an element has been removed or hidden, using its ID attribute.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>id</code> (str): The HTML id attribute value</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if element became invisible</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element still visible after timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div id=\"loading_overlay\"&gt;Please wait...&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for overlay to disappear\nComponentUtils.waitForElementNotToBeVisibleById(wait, \"loading_overlay\")\n</code></pre></p>"},{"location":"api/component-utils/#waitforelementtobevisiblebytext","title":"waitForElementToBeVisibleByText","text":"<p>Wait for an element containing specific text to become visible.</p> <p>Use this when you need to find elements by their visible text content, regardless of their HTML structure or attributes.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>text</code> (str): Exact text content to match</li> </ul> <p>Returns:</p> <ul> <li><code>WebElement</code>: The element containing the text</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not visible within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"notification\"&gt;\n  &lt;p&gt;Your changes have been saved&lt;/p&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for specific text to appear\nelement = ComponentUtils.waitForElementToBeVisibleByText(\n    wait, \n    \"Your changes have been saved\"\n)\n</code></pre></p>"},{"location":"api/component-utils/#waitforelementnottobevisiblebytext","title":"waitForElementNotToBeVisibleByText","text":"<p>Wait until an element with specific text is no longer visible.</p> <p>Use this to verify that messages, notifications, or other text-based elements have disappeared.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>text</code> (str): Exact text content to match</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if element became invisible</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element still visible after timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"toast-message\"&gt;Processing...&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Wait for processing message to disappear\nComponentUtils.waitForElementNotToBeVisibleByText(wait, \"Processing...\")\n</code></pre></p>"},{"location":"api/component-utils/#findcomponentbyid","title":"findComponentById","text":"<p>Find and return an element by its ID attribute.</p> <p>Use this when you need to locate an element by ID and wait for it to be present in the DOM (but not necessarily visible).</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>id</code> (str): The HTML id attribute value</li> </ul> <p>Returns:</p> <ul> <li><code>WebElement</code>: The located element</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not found within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;input id=\"username_field\" type=\"text\" /&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Find element by ID\ninput_field = ComponentUtils.findComponentById(wait, \"username_field\")\ninput_field.send_keys(\"test_user\")\n</code></pre></p>"},{"location":"api/component-utils/#checkcomponentexistsbyxpath","title":"checkComponentExistsByXpath","text":"<p>Check if a component exists without throwing an exception.</p> <p>Use this when you want to conditionally perform actions based on element presence, such as closing optional dialogs or handling dynamic UI elements.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>xpath</code> (str): XPath expression to locate the element</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if element exists and is visible, False otherwise</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Optional cookie banner --&gt;\n&lt;div id=\"cookie_banner\"&gt;\n  &lt;button&gt;Accept Cookies&lt;/button&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Check if cookie banner exists before dismissing\nif ComponentUtils.checkComponentExistsByXpath(wait, \"//div[@id='cookie_banner']\"):\n    # Close the banner\n    ComponentUtils.findComponentUsingXpathAndClick(wait, \"//button[text()='Accept Cookies']\")\n</code></pre></p>"},{"location":"api/component-utils/#findcount","title":"findCount","text":"<p>Count the number of elements matching an XPath expression.</p> <p>Use this to determine how many elements match a pattern, such as counting table rows, list items, or validation errors.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>xpath</code> (str): XPath expression to locate elements</li> </ul> <p>Returns:</p> <ul> <li><code>int</code>: Number of matching elements (0 if none found)</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;ul class=\"item-list\"&gt;\n  &lt;li class=\"item\"&gt;Item 1&lt;/li&gt;\n  &lt;li class=\"item\"&gt;Item 2&lt;/li&gt;\n  &lt;li class=\"item\"&gt;Item 3&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Count list items\ncount = ComponentUtils.findCount(wait, \"//li[@class='item']\")\nprint(f\"Found {count} items\")  # \"Found 3 items\"\n</code></pre></p>"},{"location":"api/component-utils/#tab","title":"tab","text":"<p>Simulate a Tab key press.</p> <p>Use this to navigate between form fields using keyboard navigation, which can be more reliable than clicking in certain Appian forms.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Examples:</p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\nfrom robo_appian.components.InputUtils import InputUtils\n\n# Fill first field\nInputUtils.setValueByLabelText(wait, \"First Name\", \"John\")\n\n# Tab to next field\nComponentUtils.tab(wait)\n\n# Continue with next field\nInputUtils.setValueByLabelText(wait, \"Last Name\", \"Doe\")\n</code></pre></p>"},{"location":"api/component-utils/#today","title":"today","text":"<p>Get today's date formatted as MM/DD/YYYY.</p> <p>Use this for populating date fields with the current date in Appian's expected format.</p> <p>Args:</p> <ul> <li>None</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Today's date in MM/DD/YYYY format</li> </ul> <p>Examples:</p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\nfrom robo_appian.components.DateUtils import DateUtils\n\n# Set date field to today\ntoday_date = ComponentUtils.today()\nDateUtils.setValueByLabelText(wait, \"Submission Date\", today_date)\n</code></pre></p>"},{"location":"api/component-utils/#yesterday","title":"yesterday","text":"<p>Get yesterday's date formatted as MM/DD/YYYY.</p> <p>Use this for populating date fields with yesterday's date, useful for testing date range filters or historical data entry.</p> <p>Args:</p> <ul> <li>None</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Yesterday's date in MM/DD/YYYY format</li> </ul> <p>Examples:</p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\nfrom robo_appian.components.DateUtils import DateUtils\n\n# Set start date to yesterday\nyesterday_date = ComponentUtils.yesterday()\nDateUtils.setValueByLabelText(wait, \"Start Date\", yesterday_date)\n</code></pre></p>"},{"location":"api/component-utils/#get_version","title":"get_version","text":"<p>Get the current version of robo_appian from pyproject.toml.</p> <p>Use this for logging, diagnostics, or version compatibility checks in your test framework.</p> <p>Args:</p> <ul> <li>None</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Version string (e.g., \"0.0.33\") or \"0.0.0\" if unable to read</li> </ul> <p>Examples:</p> <p>Python: <pre><code>from robo_appian.utils.ComponentUtils import ComponentUtils\n\n# Log version in test setup\nversion = ComponentUtils.get_version()\nprint(f\"Running tests with robo_appian v{version}\")\n</code></pre></p>"},{"location":"api/date-utils/","title":"Date Utils","text":""},{"location":"api/date-utils/#overview","title":"Overview","text":"<p>DateUtils provides methods to interact with Appian date picker components. Use DateUtils to fill date fields by their label, clear existing dates, or click to open calendar pickers. All date values should be formatted as MM/DD/YYYY to match Appian's expected format.</p>"},{"location":"api/date-utils/#methods","title":"Methods","text":""},{"location":"api/date-utils/#setvaluebylabeltext","title":"setValueByLabelText","text":"<p>Set a date value in a date picker by its associated label.</p> <p>Use this when you need to fill a date field and you know the exact label text displayed next to or above the date picker. This method automatically waits for the date input to be clickable, clears any existing value, and enters the new date. Perfect for form submissions where dates are required fields.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the date picker</li> <li><code>value</code> (str): Date string in MM/DD/YYYY format (e.g., \"01/15/2024\")</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If date picker not found or not clickable within timeout</li> </ul> <p>Returns:</p> <ul> <li>WebElement representing the date input component</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;label&gt;End Date&lt;/label&gt;\n  &lt;input type=\"text\" class=\"date-picker\" placeholder=\"MM/DD/YYYY\" /&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DateUtils import DateUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nDateUtils.setValueByLabelText(wait, \"End Date\", \"12/31/2024\")\n</code></pre></p>"},{"location":"api/date-utils/#clickbylabeltext","title":"clickByLabelText","text":"<p>Click on a date picker field to open the calendar popup.</p> <p>Use this when you need to interact with the date picker's calendar interface rather than typing a date directly. This opens the visual calendar widget where users can select dates by clicking on days. Useful for exploring date selections or when the date picker requires calendar interaction for validation.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the date picker</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If date picker not found or not clickable within timeout</li> </ul> <p>Returns:</p> <ul> <li>WebElement representing the date input component</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;label&gt;Event Date&lt;/label&gt;\n  &lt;input type=\"text\" class=\"date-picker\" placeholder=\"MM/DD/YYYY\" /&gt;\n  &lt;!-- Clicking input opens calendar popup --&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DateUtils import DateUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Click to open the calendar picker\nDateUtils.clickByLabelText(wait, \"Event Date\")\n# Calendar popup appears for visual date selection\n</code></pre></p>"},{"location":"api/dropdown-utils/","title":"Dropdown Utils","text":""},{"location":"api/dropdown-utils/#overview","title":"Overview","text":"<p>DropdownUtils provides methods to interact with Appian dropdown components. Use DropdownUtils to select options from dropdowns by their label, check if dropdowns are enabled or read-only, retrieve all available options, and verify specific options exist. Dropdowns use the combobox ARIA pattern with clickable triggers and option lists.</p>"},{"location":"api/dropdown-utils/#methods","title":"Methods","text":""},{"location":"api/dropdown-utils/#selectdropdownvaluebylabeltext","title":"selectDropdownValueByLabelText","text":"<p>Select an option from a dropdown by the dropdown's exact label text.</p> <p>Use this when you need to select a specific option from a dropdown and you know the exact label text displayed next to or above the dropdown. This method clicks the dropdown to open it, waits for options to appear, then clicks the desired option. Perfect for form submissions where dropdown selections are required.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> <li><code>value</code> (str): Exact text of the option to select from the dropdown</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown or option not found or not clickable within timeout</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Status&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-controls=\"dropdown_123_list\"&gt;\n    &lt;span&gt;Select...&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;!-- After clicking combobox --&gt;\n&lt;ul id=\"dropdown_123_list\" role=\"listbox\"&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Active&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Inactive&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Status\", \"Active\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#selectdropdownvaluebypartiallabeltext","title":"selectDropdownValueByPartialLabelText","text":"<p>Select an option from a dropdown using partial label text matching.</p> <p>Use this when the dropdown label contains dynamic text or you only know part of the label. This method uses a contains match instead of exact match, making it useful for labels with counters, dates, or other variable content appended.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Partial label text for the dropdown (uses contains matching)</li> <li><code>value</code> (str): Exact text of the option to select</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown or option not found within timeout</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Department (25 items)&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-controls=\"dropdown_456_list\"&gt;\n    &lt;span&gt;Select...&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nDropdownUtils.selectDropdownValueByPartialLabelText(wait, \"Department\", \"Sales\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#checkeditablestatusbylabeltext","title":"checkEditableStatusByLabelText","text":"<p>Check if a dropdown is enabled (editable) or disabled by its label.</p> <p>Use this to verify whether a dropdown is interactive before attempting to select options. Returns True if the dropdown is editable, False if it's disabled. Useful in test assertions to verify conditional dropdown states based on other form selections.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> </ul> <p>Raises: None (returns False if dropdown not found)</p> <p>Returns: bool: True if dropdown is editable, False if disabled or not found</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Enabled dropdown --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Region&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-disabled=\"false\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Disabled dropdown --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Restricted Field&lt;/span&gt;\n  &lt;div aria-disabled=\"true\"&gt;Not Available&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nif DropdownUtils.checkEditableStatusByLabelText(wait, \"Region\"):\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Region\", \"North\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#getdropdownoptionvalues","title":"getDropdownOptionValues","text":"<p>Retrieve all available option values from a dropdown as a list.</p> <p>Use this when you need to verify all available options, validate dropdown content, or make dynamic selections based on available choices. This method opens the dropdown, extracts all option texts, closes the dropdown, and returns the list of options.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown not found within timeout</li> </ul> <p>Returns: list[str]: List of all option texts in the dropdown</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Priority&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-controls=\"dropdown_789_list\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n&lt;ul id=\"dropdown_789_list\" role=\"listbox\"&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;High&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Medium&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Low&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\noptions = DropdownUtils.getDropdownOptionValues(wait, \"Priority\")\nprint(options)  # ['High', 'Medium', 'Low']\nassert \"High\" in options, \"High priority option missing\"\n</code></pre></p>"},{"location":"api/dropdown-utils/#checkreadonlystatusbylabeltext","title":"checkReadOnlyStatusByLabelText","text":"<p>Check if a dropdown is read-only (disabled) by its label.</p> <p>Use this to verify whether a dropdown is in read-only mode, typically displaying a static value without allowing interaction. This is the inverse of checkEditableStatusByLabelText. Returns True if the dropdown is read-only, False if it's editable or interactive.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> </ul> <p>Raises: None (returns False if dropdown not found or an error occurs)</p> <p>Returns: bool: True if dropdown is read-only, False if editable or not found</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Read-only dropdown --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Approval Status&lt;/span&gt;\n  &lt;div aria-labelledby=\"status_label\"&gt;Approved&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Editable dropdown --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Department&lt;/span&gt;\n  &lt;div role=\"combobox\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nif DropdownUtils.checkReadOnlyStatusByLabelText(wait, \"Approval Status\"):\n    print(\"Dropdown is read-only, cannot modify\")\nelse:\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Approval Status\", \"Pending\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#selectdropdownvaluebycomboboxcomponent","title":"selectDropdownValueByComboboxComponent","text":"<p>Select a dropdown option when you already have the combobox WebElement.</p> <p>Use this advanced method when you've already located the combobox element through other means and want to select an option directly. Useful in complex scenarios where you're iterating through multiple dropdowns or have custom element discovery logic. Skips the label-based lookup step.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>combobox</code> (WebElement): The combobox WebElement already located</li> <li><code>value</code> (str): Exact text of the option to select</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If option not found within timeout</li> <li><code>ValueError</code>: If combobox lacks required attributes</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"combobox\" id=\"custom_dropdown\" aria-controls=\"options_list\"&gt;\n  &lt;span&gt;Select...&lt;/span&gt;\n&lt;/div&gt;\n&lt;ul id=\"options_list\" role=\"listbox\"&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Option A&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Option B&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\n\ncombobox = wait.until(EC.element_to_be_clickable((By.ID, \"custom_dropdown\")))\nDropdownUtils.selectDropdownValueByComboboxComponent(wait, combobox, \"Option A\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#waitfordropdowntobeenabled","title":"waitForDropdownToBeEnabled","text":"<p>Wait for a dropdown to transition from disabled to enabled state.</p> <p>Use this when a dropdown becomes interactive after other form actions complete (e.g., after selecting a region, the city dropdown becomes enabled). Polls the dropdown's editable status at regular intervals until it becomes enabled or the timeout expires. Useful for handling dynamic form behavior.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> <li><code>wait_interval</code> (float): Seconds to wait between status checks (default: 0.5)</li> <li><code>timeout</code> (int): Maximum seconds to wait for dropdown to enable (default: 2)</li> </ul> <p>Raises: None (returns False if timeout expires)</p> <p>Returns: bool: True if dropdown becomes enabled within timeout, False otherwise</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Country&lt;/span&gt;\n  &lt;div role=\"combobox\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n&lt;!-- Initially disabled --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;State&lt;/span&gt;\n  &lt;div aria-disabled=\"true\"&gt;Select country first&lt;/div&gt;\n&lt;/div&gt;\n&lt;!-- After selecting country, becomes enabled --&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Country\", \"United States\")\n\nif DropdownUtils.waitForDropdownToBeEnabled(wait, \"State\", wait_interval=0.5, timeout=5):\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"State\", \"California\")\nelse:\n    print(\"State dropdown did not become enabled\")\n</code></pre></p>"},{"location":"api/dropdown-utils/#checkdropdownoptionvalueexists","title":"checkDropdownOptionValueExists","text":"<p>Check if a specific option value exists in a dropdown's option list.</p> <p>Use this to verify that expected options are available before attempting to select them, or to validate dropdown content in tests. Opens the dropdown, searches for the option, and returns whether it exists. Non-destructive check that doesn't modify the dropdown selection.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> <li><code>value</code> (str): Exact text of the option to check for</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown not found within timeout</li> </ul> <p>Returns: bool: True if the option exists in the dropdown, False otherwise</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Priority&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-controls=\"priority_list\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n&lt;ul id=\"priority_list\" role=\"listbox\"&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;High&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;Medium&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nif DropdownUtils.checkDropdownOptionValueExists(wait, \"Priority\", \"High\"):\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Priority\", \"High\")\nelse:\n    print(\"High priority option not available\")\n\nassert DropdownUtils.checkDropdownOptionValueExists(wait, \"Priority\", \"Critical\"), \"Critical option missing\"\n</code></pre></p>"},{"location":"api/dropdown-utils/#waitfordropdownvaluestobechanged","title":"waitForDropdownValuesToBeChanged","text":"<p>Wait for a dropdown's available options to change from an initial set of values.</p> <p>Use this when dropdown options are dynamically populated based on other form selections. Compares the current dropdown options against an initial snapshot, polling at regular intervals until the options change or timeout expires. Essential for handling cascading dropdowns where options in one dropdown depend on the selection in another.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> <li><code>initial_values</code> (list[str]): Initial list of option values to compare against</li> <li><code>poll_frequency</code> (float): Seconds to wait between checks (default: 0.5)</li> <li><code>timeout</code> (int): Maximum seconds to wait for values to change (default: 2)</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown not found within timeout</li> </ul> <p>Returns: None (exits loop when values change or timeout expires)</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Department&lt;/span&gt;\n  &lt;div role=\"combobox\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n&lt;!-- Job Title dropdown options change based on Department selection --&gt;\n&lt;div role=\"presentation\"&gt;\n  &lt;span&gt;Job Title&lt;/span&gt;\n  &lt;div role=\"combobox\" aria-controls=\"job_list\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.DropdownUtils import DropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ninitial_jobs = DropdownUtils.getDropdownOptionValues(wait, \"Job Title\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Department\", \"Engineering\")\n\nDropdownUtils.waitForDropdownValuesToBeChanged(\n    wait, \n    \"Job Title\", \n    initial_jobs, \n    poll_frequency=0.5, \n    timeout=5\n)\n\nnew_jobs = DropdownUtils.getDropdownOptionValues(wait, \"Job Title\")\nprint(f\"Job titles updated: {new_jobs}\")\n</code></pre></p>"},{"location":"api/input-utils/","title":"Input Utils","text":""},{"location":"api/input-utils/#overview","title":"Overview","text":"<p>InputUtils provides reliable text input interactions using visible label text. Inputs can be located by exact label match, partial label match, HTML id attributes, or placeholder text.</p> <p>All input operations handle timing issues automatically and clear existing values before entering new text.</p>"},{"location":"api/input-utils/#methods","title":"Methods","text":""},{"location":"api/input-utils/#setvaluebylabeltext","title":"setValueByLabelText","text":"<p>Set value in an input field by its exact label text.</p> <p>Use this when you know the complete, exact label text associated with the input field. This is the most precise way to interact with inputs and works best when label text is stable and consistent across your application.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Exact visible label text to match</li> <li><code>value</code> (str): Text to enter into the input field</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If label element has no 'for' attribute linking to input</li> <li><code>TimeoutException</code>: If label or input not found within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;label for=\"username_input\"&gt;Username&lt;/label&gt;\n  &lt;input id=\"username_input\" type=\"text\" /&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.InputUtils import InputUtils\n\nInputUtils.setValueByLabelText(wait, \"Username\", \"john_doe\")\n</code></pre></p>"},{"location":"api/input-utils/#setvaluebypartiallabeltext","title":"setValueByPartialLabelText","text":"<p>Set value in an input field by partial label match.</p> <p>Use this when you only know part of the label text, or when labels include dynamic content. Perfect for situations where the full label might change but a key word remains constant (e.g., \"Name\" appears in \"First Name\", \"User Name\", etc.).</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>label</code> (str): Partial label text to match</li> <li><code>value</code> (str): Text to enter into the input field</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If label element has no 'for' attribute linking to input</li> <li><code>TimeoutException</code>: If label or input not found within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;label for=\"first_name_input\"&gt;First Name&lt;/label&gt;\n  &lt;input id=\"first_name_input\" type=\"text\" /&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.InputUtils import InputUtils\n\n# Matches \"First Name\", \"User Name\", \"Full Name\", etc.\nInputUtils.setValueByPartialLabelText(wait, \"Name\", \"John\")\n</code></pre></p>"},{"location":"api/input-utils/#setvaluebyid","title":"setValueById","text":"<p>Set value in an input field by its HTML id attribute.</p> <p>Use this when the input has a specific HTML id and label-based selection isn't suitable. This is useful for inputs without visible labels or when you need to target a specific field among several with similar labels.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>id</code> (str): The HTML id attribute of the input element</li> <li><code>value</code> (str): Text to enter into the input field</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If input not found within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;input id=\"email_input\" type=\"email\" /&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.InputUtils import InputUtils\n\nInputUtils.setValueById(wait, \"email_input\", \"user@example.com\")\n</code></pre></p>"},{"location":"api/input-utils/#setvaluebyplaceholdertext","title":"setValueByPlaceholderText","text":"<p>Set value in an input field by its placeholder text.</p> <p>Use this when the input field has placeholder text but no visible label. Placeholder text is the hint text that appears inside an empty input field (e.g., \"Enter your email\").</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance</li> <li><code>text</code> (str): The placeholder text of the input field</li> <li><code>value</code> (str): Text to enter into the input field</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If input not found within timeout</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;input type=\"email\" placeholder=\"Enter your email\" /&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.InputUtils import InputUtils\n\nInputUtils.setValueByPlaceholderText(wait, \"Enter your email\", \"user@example.com\")\n</code></pre></p>"},{"location":"api/label-utils/","title":"Label Utils","text":""},{"location":"api/label-utils/#overview","title":"Overview","text":"<p>LabelUtils provides methods to find and verify text labels, headings, and other text elements in Appian UI. Use LabelUtils to check for the presence of labels or text content that don't fit into form component categories. Useful for validation steps that verify page content, success messages, or error messages before or after actions.</p>"},{"location":"api/label-utils/#methods","title":"Methods","text":""},{"location":"api/label-utils/#islabelexists","title":"isLabelExists","text":"<p>Check if a label or text element with exact text exists on the page.</p> <p>Use this for non-blocking validation checks in test assertions or conditional logic. Returns False if the label is not found or times out, without raising an exception. Perfect for verifying success messages, error messages, or any text content that indicates a state or result.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible text to search for</li> </ul> <p>Raises: None (returns False instead of raising exceptions)</p> <p>Returns: bool: True if label found and visible, False otherwise</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;span&gt;Success!&lt;/span&gt;\n  &lt;p&gt;Your form has been submitted.&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;div class=\"error-message\"&gt;\n  &lt;strong&gt;Error: Invalid input&lt;/strong&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.LabelUtils import LabelUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nif LabelUtils.isLabelExists(wait, \"Success!\"):\n    print(\"Form submitted successfully\")\n\nassert LabelUtils.isLabelExists(wait, \"Your form has been submitted.\"), \"Success message not found\"\n</code></pre></p>"},{"location":"api/label-utils/#clickbylabeltext","title":"clickByLabelText","text":"<p>Click a label or text element by its exact visible text.</p> <p>Use this when you need to interact with text elements that trigger UI changes, such as collapsible section headers, expandable panels, or clickable labels. This method finds the element by its text and clicks it using reliable ActionChains interaction.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible text of the element to click</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If element not found or not clickable within timeout</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"collapsible-header\" onclick=\"toggleSection()\"&gt;\n  &lt;span&gt;Expand Details&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;div class=\"clickable-label\"&gt;\n  &lt;strong&gt;Show More&lt;/strong&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.LabelUtils import LabelUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nLabelUtils.clickByLabelText(wait, \"Expand Details\")\nLabelUtils.clickByLabelText(wait, \"Show More\")\n</code></pre></p>"},{"location":"api/label-utils/#islabelexistsafterload","title":"isLabelExistsAfterLoad","text":"<p>Check if a label exists after explicitly waiting for it to become visible.</p> <p>Use this for stricter validation that ensures the element is not only present in the DOM but also visible to the user. Unlike isLabelExists which may find hidden elements, this method waits for the element to become visible. Ideal for checking messages that appear after page loads or form submissions complete.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible text to search for</li> </ul> <p>Raises: None (returns False instead of raising exceptions)</p> <p>Returns: bool: True if label becomes visible within timeout, False otherwise</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;!-- Initially hidden, becomes visible after AJAX call --&gt;\n&lt;div id=\"success-message\" style=\"display: none;\"&gt;\n  &lt;span&gt;Saved successfully&lt;/span&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.LabelUtils import LabelUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Wait for success message to appear after form submission\nif LabelUtils.isLabelExistsAfterLoad(wait, \"Saved successfully\"):\n    print(\"Form saved and message displayed\")\nelse:\n    print(\"Success message did not appear\")\n</code></pre></p>"},{"location":"api/link-utils/","title":"Link Utils","text":""},{"location":"api/link-utils/#overview","title":"Overview","text":"<p>LinkUtils provides methods to find and click hyperlinks in Appian UI. Use LinkUtils to interact with links using their visible text label. Automatically waits for clickability and handles hidden or overlay states.</p>"},{"location":"api/link-utils/#methods","title":"Methods","text":""},{"location":"api/link-utils/#click","title":"click","text":"<p>Click a hyperlink by its exact visible text.</p> <p>Use this when you need to navigate by clicking a link and you know the exact text displayed on the link. This method waits for the link to be clickable and uses ActionChains for reliable interaction even when links are covered by animations, tooltips, or other overlays.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible text of the link to click</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If link not found or not clickable within timeout</li> </ul> <p>Returns: WebElement representing the link that was clicked</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"navigation\"&gt;\n  &lt;a href=\"/details\"&gt;View Details&lt;/a&gt;\n  &lt;a href=\"/edit\"&gt;Edit&lt;/a&gt;\n  &lt;a href=\"/help\"&gt;Learn More&lt;/a&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.LinkUtils import LinkUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nLinkUtils.click(wait, \"Learn More\")\n</code></pre></p>"},{"location":"api/link-utils/#find","title":"find","text":"<p>Find a link element by its exact visible text without clicking it.</p> <p>Use this when you need to inspect a link element or perform custom operations on it before clicking. Returns the link WebElement for advanced use cases like checking the href attribute, getting link text, or validating link properties. Most commonly you'll use the click method instead, but this is useful for validation or custom interactions.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible text of the link</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If link not found within timeout</li> </ul> <p>Returns: WebElement representing the link element</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"navigation\"&gt;\n  &lt;a href=\"/profile/edit\"&gt;Edit Profile&lt;/a&gt;\n  &lt;a href=\"/settings\"&gt;Settings&lt;/a&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.LinkUtils import LinkUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nlink = LinkUtils.find(wait, \"Edit Profile\")\nprint(f\"Link URL: {link.get_attribute('href')}\")\nassert \"/profile/edit\" in link.get_attribute('href'), \"Incorrect link URL\"\n</code></pre></p>"},{"location":"api/robo-utils/","title":"Robo Utils","text":""},{"location":"api/robo-utils/#overview","title":"Overview","text":"<p>RoboUtils provides resilience utilities for handling flaky operations. The primary feature is automatic retry logic for operations that may encounter timeout exceptions.</p> <p>Use these utilities to make your tests more robust against temporary delays, network issues, or animation timing problems.</p>"},{"location":"api/robo-utils/#methods","title":"Methods","text":""},{"location":"api/robo-utils/#retry_on_timeout","title":"retry_on_timeout","text":"<p>Automatically retry an operation that may fail due to timeout exceptions.</p> <p>Use this to wrap flaky operations like waiting for slow-loading elements, clicking buttons that trigger animations, or interacting with elements during page transitions. The method retries only on TimeoutException; other exceptions are immediately re-raised.</p> <p>Args:</p> <ul> <li><code>operation</code> (callable): A function or lambda that performs the desired operation (takes no arguments)</li> <li><code>max_retries</code> (int): Maximum number of total attempts (initial + retries). Default is 3</li> <li><code>operation_name</code> (str): Descriptive name for the operation (used in error messages). Default is \"operation\"</li> </ul> <p>Returns:</p> <ul> <li>The return value from the successful execution of the operation</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If operation fails with TimeoutException for all retry attempts</li> <li><code>Exception</code>: Any non-timeout exceptions are immediately re-raised without retry</li> </ul> <p>Examples:</p> <p>HTML: <pre><code>&lt;button id=\"load_more\" onclick=\"loadMoreItems()\"&gt;\n  Load More\n&lt;/button&gt;\n&lt;!-- JavaScript delays rendering new items --&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components.ButtonUtils import ButtonUtils\n\n# Wrap a flaky button click operation\ndef click_load_more():\n    ButtonUtils.clickByLabelText(wait, \"Load More\")\n\n# Retry up to 3 times if timeout occurs\nRoboUtils.retry_on_timeout(\n    click_load_more, \n    max_retries=3, \n    operation_name=\"Load More Click\"\n)\n</code></pre></p> <p>Advanced Example - Retrying Complex Operations:</p> <pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components import InputUtils, DropdownUtils, ButtonUtils\n\ndef submit_form():\n    \"\"\"Multi-step form submission that might timeout\"\"\"\n    InputUtils.setValueByLabelText(wait, \"Title\", \"Test Request\")\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Priority\", \"High\")\n    ButtonUtils.clickByLabelText(wait, \"Submit\")\n\n# Retry entire form submission up to 5 times\nRoboUtils.retry_on_timeout(\n    submit_form,\n    max_retries=5,\n    operation_name=\"Form Submission\"\n)\n</code></pre> <p>Using with Lambda Functions:</p> <pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components.LabelUtils import LabelUtils\n\n# Retry checking for a success message\nresult = RoboUtils.retry_on_timeout(\n    lambda: LabelUtils.isLabelExists(wait, \"Successfully Saved\"),\n    max_retries=3,\n    operation_name=\"Check Success Message\"\n)\n</code></pre> <p>Handling Return Values:</p> <pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components.TableUtils import TableUtils\n\n# Retry getting table row count\ndef get_row_count():\n    table = TableUtils.findTableByColumnName(wait, \"Employee ID\")\n    return TableUtils.rowCount(table)\n\nrow_count = RoboUtils.retry_on_timeout(\n    get_row_count,\n    max_retries=3,\n    operation_name=\"Get Table Rows\"\n)\nprint(f\"Table has {row_count} rows\")\n</code></pre>"},{"location":"api/robo-utils/#best-practices","title":"Best Practices","text":""},{"location":"api/robo-utils/#when-to-use-retry-logic","title":"When to Use Retry Logic","text":"<p>Good Use Cases: - Elements that load after animations or transitions - Operations affected by network latency - Click actions on elements that trigger async operations - Waiting for dynamically generated content</p> <p>Avoid Overuse: - Don't mask real failures - if an operation consistently times out, fix the root cause - Avoid high retry counts (3-5 is usually sufficient) - Don't use for operations that should fail fast (authentication, validation errors)</p>"},{"location":"api/robo-utils/#logging-and-debugging","title":"Logging and Debugging","text":"<p>RoboUtils uses Python's logging module. Configure logging in your test setup to see retry attempts:</p> <pre><code>import logging\n\n# Configure logging to see retry messages\nlogging.basicConfig(\n    level=logging.WARNING,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Now retry messages will be logged\nfrom robo_appian.utils.RoboUtils import RoboUtils\n\nRoboUtils.retry_on_timeout(\n    lambda: ButtonUtils.clickByLabelText(wait, \"Submit\"),\n    max_retries=3,\n    operation_name=\"Submit Button\"\n)\n</code></pre>"},{"location":"api/robo-utils/#combining-with-other-utilities","title":"Combining with Other Utilities","text":"<pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components import SearchDropdownUtils, DateUtils, ButtonUtils\n\ndef fill_and_submit_form():\n    \"\"\"Complex form interaction with multiple components\"\"\"\n    # Search dropdown can be slow\n    SearchDropdownUtils.selectSearchDropdownValueByLabelText(\n        wait, \n        \"Approver\", \n        \"John Smith\"\n    )\n\n    # Date picker interaction\n    DateUtils.setValueByLabelText(wait, \"Due Date\", \"12/31/2025\")\n\n    # Submit button\n    ButtonUtils.clickByLabelText(wait, \"Submit\")\n\n# Retry the entire sequence\nRoboUtils.retry_on_timeout(\n    fill_and_submit_form,\n    max_retries=3,\n    operation_name=\"Fill and Submit Form\"\n)\n</code></pre>"},{"location":"api/search-dropdown-utils/","title":"Search Dropdown Utils","text":""},{"location":"api/search-dropdown-utils/#overview","title":"Overview","text":"<p>SearchDropdownUtils provides methods to interact with search-enabled dropdown components in Appian. Search dropdowns allow users to type to filter available options before selecting. These components differ from standard dropdowns because they include a search input field. The utility automatically types the search term, waits for filtered options to populate, then clicks the matching option.</p>"},{"location":"api/search-dropdown-utils/#methods","title":"Methods","text":""},{"location":"api/search-dropdown-utils/#selectsearchdropdownvaluebylabeltext","title":"selectSearchDropdownValueByLabelText","text":"<p>Select a value from a search dropdown using exact label match.</p> <p>Use this when you need to select from a searchable dropdown with a large number of options and you know the exact label text. This method clicks the dropdown, types the value into the search field to filter options, waits for the filtered list to appear, then clicks the matching option. Efficient for dropdowns with hundreds or thousands of options.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the dropdown</li> <li><code>value</code> (str): Exact text of the option to select</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown or option not found within timeout</li> <li><code>ValueError</code>: If dropdown ID cannot be extracted</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;span&gt;Employee&lt;/span&gt;\n  &lt;div role=\"combobox\" id=\"employee_value\"&gt;\n    &lt;span&gt;Select...&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;!-- After clicking --&gt;\n&lt;input id=\"employee_searchInput\" type=\"text\" placeholder=\"Search...\" /&gt;\n&lt;ul id=\"employee_list\" role=\"listbox\"&gt;\n  &lt;li&gt;&lt;div&gt;John Doe&lt;/div&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;div&gt;Jane Smith&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.SearchDropdownUtils import SearchDropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nSearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Employee\", \"John Doe\")\n</code></pre></p>"},{"location":"api/search-dropdown-utils/#selectsearchdropdownvaluebypartiallabeltext","title":"selectSearchDropdownValueByPartialLabelText","text":"<p>Select a value from a search dropdown using partial label match.</p> <p>Use this when the dropdown label contains dynamic text or you only know part of the label. This method uses a contains match for the label, making it useful for labels with counters, dates, or other variable content.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Partial label text (uses contains matching)</li> <li><code>value</code> (str): Exact text of the option to select</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If dropdown or option not found within timeout</li> <li><code>ValueError</code>: If dropdown ID cannot be extracted</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;span&gt;Employee (1,234 items)&lt;/span&gt;\n  &lt;div role=\"combobox\" id=\"employee_value\"&gt;Select...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.SearchDropdownUtils import SearchDropdownUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nSearchDropdownUtils.selectSearchDropdownValueByPartialLabelText(wait, \"Employee\", \"John Doe\")\n</code></pre></p>"},{"location":"api/search-input-utils/","title":"Search Input Utils","text":""},{"location":"api/search-input-utils/#overview","title":"Overview","text":"<p>SearchInputUtils provides methods to interact with searchable input components in Appian. Similar to SearchDropdownUtils, but for input fields that support filtering and selection from a dropdown list. Use SearchInputUtils when you need to type into a search field and select a matching option from the results.</p>"},{"location":"api/search-input-utils/#methods","title":"Methods","text":""},{"location":"api/search-input-utils/#selectsearchdropdownbylabeltext","title":"selectSearchDropdownByLabelText","text":"<p>Select a value from a search input using exact label match.</p> <p>Use this when you need to search and select from an input field that provides autocomplete or filtered suggestions. This method types the search term into the input, waits for the listbox options to populate, then clicks the matching option. Common in Appian forms for employee selection, user lookup, or any searchable entity.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact label text for the search input</li> <li><code>value</code> (str): Exact text of the option to select from dropdown</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If input or option not found within timeout</li> <li><code>ValueError</code>: If input does not have 'aria-controls' attribute</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;span&gt;Employee Name&lt;/span&gt;\n  &lt;input role=\"combobox\" aria-controls=\"employee_listbox\" /&gt;\n&lt;/div&gt;\n&lt;!-- After typing --&gt;\n&lt;ul id=\"employee_listbox\" role=\"listbox\"&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;John Doe&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;\n  &lt;li role=\"option\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;John Smith&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.SearchInputUtils import SearchInputUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nSearchInputUtils.selectSearchDropdownByLabelText(wait, \"Employee Name\", \"John Doe\")\n</code></pre></p>"},{"location":"api/search-input-utils/#selectsearchdropdownbypartiallabeltext","title":"selectSearchDropdownByPartialLabelText","text":"<p>Select a value from a search input using partial label match.</p> <p>Use this when the search input label contains dynamic text or you only know part of the label. This method uses a contains match for the label, making it useful for labels with counters, dates, or other variable content. Otherwise behaves the same as selectSearchDropdownByLabelText.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Partial label text (uses contains matching)</li> <li><code>value</code> (str): Exact text of the option to select from dropdown</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If input or option not found within timeout</li> <li><code>ValueError</code>: If input does not have 'aria-controls' attribute</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div&gt;\n  &lt;span&gt;Employee (1,234 total)&lt;/span&gt;\n  &lt;input role=\"combobox\" aria-controls=\"employee_listbox\" /&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.SearchInputUtils import SearchInputUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nSearchInputUtils.selectSearchDropdownByPartialLabelText(wait, \"Employee\", \"John Doe\")\n</code></pre></p>"},{"location":"api/tab-utils/","title":"Tab Utils","text":""},{"location":"api/tab-utils/#overview","title":"Overview","text":"<p>TabUtils provides methods to select and interact with tab components in Appian UI. Use TabUtils to navigate between different sections within a single page. Tabs are commonly used in Appian to organize related content, and clicking a tab triggers content reloads in the tab panel.</p>"},{"location":"api/tab-utils/#methods","title":"Methods","text":""},{"location":"api/tab-utils/#selecttabbylabeltext","title":"selectTabByLabelText","text":"<p>Click a tab to navigate to it by its exact visible label.</p> <p>Use this when you need to switch between different tab sections in an Appian interface. After clicking the tab, content within the tab panel will load, so be ready to wait for elements within the new tab section before interacting with them.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible label text of the tab to select</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If tab not found or not clickable within timeout</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"tabs\"&gt;\n  &lt;div role=\"link\"&gt;\n    &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;Details&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div role=\"link\"&gt;\n    &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;History&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TabUtils import TabUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nTabUtils.selectTabByLabelText(wait, \"Details\")\n</code></pre></p>"},{"location":"api/tab-utils/#findtabbylabeltext","title":"findTabByLabelText","text":"<p>Find a tab element by its exact visible label without clicking it.</p> <p>Use this when you need to inspect a tab element or perform custom operations on it before clicking. Returns the tab WebElement for advanced use cases like checking attributes, getting position, or chaining operations. Most commonly you'll use selectTabByLabelText instead, but this is useful for validation or custom interactions.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible label text of the tab</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If tab not found within timeout</li> </ul> <p>Returns: WebElement representing the tab element</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div class=\"tabs\"&gt;\n  &lt;div role=\"link\"&gt;\n    &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;Details&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TabUtils import TabUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ntab = TabUtils.findTabByLabelText(wait, \"Details\")\nprint(f\"Tab text: {tab.text}\")\n</code></pre></p>"},{"location":"api/tab-utils/#checktabselectedbylabeltext","title":"checkTabSelectedByLabelText","text":"<p>Check if a specific tab is currently selected (active).</p> <p>Use this to verify that navigation to a tab was successful, or to check the current active tab state in test assertions. Returns True if the tab has the \"Selected Tab\" indicator, False otherwise. Useful for confirming that clicking a tab actually activated it before interacting with tab content.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>label</code> (str): Exact visible label text of the tab to check</li> </ul> <p>Raises: None (returns False if tab not found or not selected)</p> <p>Returns: bool: True if tab is currently selected, False otherwise</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;div role=\"link\"&gt;\n  &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;\n    &lt;p&gt;Details&lt;/p&gt;\n    &lt;span&gt;Selected Tab.&lt;/span&gt;\n  &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;div role=\"link\"&gt;\n  &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;\n    &lt;p&gt;History&lt;/p&gt;\n  &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TabUtils import TabUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nTabUtils.selectTabByLabelText(wait, \"Details\")\n\nif TabUtils.checkTabSelectedByLabelText(wait, \"Details\"):\n    print(\"Details tab is now active\")\n\nassert TabUtils.checkTabSelectedByLabelText(wait, \"Details\"), \"Details tab should be selected\"\n</code></pre></p>"},{"location":"api/table-utils/","title":"Table Utils","text":""},{"location":"api/table-utils/#overview","title":"Overview","text":"<p>TableUtils provides methods to interact with Appian grid and table components. Use TableUtils to read cells, click rows, find elements within table cells, and query tables using column names and row indices. Tables are located by their column headers, and rows are accessed using 0-based indexing in public APIs (internally converted to 1-based for Appian's DOM structure).</p>"},{"location":"api/table-utils/#methods","title":"Methods","text":""},{"location":"api/table-utils/#findtablebycolumnname","title":"findTableByColumnName","text":"<p>Find a table element by any of its column names.</p> <p>Use this when you need to locate a table component and you know one of its column header names. Returns the table WebElement for further operations like counting rows or extracting data. Essential for identifying the correct table when multiple tables exist on the page.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>column_name</code> (str): Exact column header text (from the abbr attribute)</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If table with specified column not found within timeout</li> </ul> <p>Returns: WebElement representing the table</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th abbr=\"Employee ID\" scope=\"col\"&gt;Employee ID&lt;/th&gt;\n      &lt;th abbr=\"Name\" scope=\"col\"&gt;Name&lt;/th&gt;\n      &lt;th abbr=\"Status\" scope=\"col\"&gt;Status&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr data-dnd-name=\"row 1\"&gt;\n      &lt;td&gt;001&lt;/td&gt;\n      &lt;td&gt;John Doe&lt;/td&gt;\n      &lt;td&gt;Active&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TableUtils import TableUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ntable = TableUtils.findTableByColumnName(wait, \"Employee ID\")\n</code></pre></p>"},{"location":"api/table-utils/#rowcount","title":"rowCount","text":"<p>Count the number of data rows in a table.</p> <p>Use this to verify table content, validate search results, or determine if a table has data before processing rows. Excludes empty grid message rows, returning only actual data rows. Returns 0 if the table is empty.</p> <p>Args:</p> <ul> <li><code>table</code> (WebElement): Table element (obtained from findTableByColumnName)</li> </ul> <p>Raises: None</p> <p>Returns: int: Number of data rows in the table</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;table&gt;\n  &lt;tbody&gt;\n    &lt;tr data-dnd-name=\"row 1\"&gt;&lt;td&gt;Data 1&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr data-dnd-name=\"row 2\"&gt;&lt;td&gt;Data 2&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr data-dnd-name=\"row 3\"&gt;&lt;td&gt;Data 3&lt;/td&gt;&lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TableUtils import TableUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ntable = TableUtils.findTableByColumnName(wait, \"Name\")\ncount = TableUtils.rowCount(table)\nprint(f\"Table has {count} rows\")\nassert count &gt; 0, \"Table should have data\"\n</code></pre></p>"},{"location":"api/table-utils/#selectrowfromtablebycolumnnameandrownumber","title":"selectRowFromTableByColumnNameAndRowNumber","text":"<p>Click a table row to select it or trigger row actions.</p> <p>Use this to select a row by clicking anywhere on it, typically to highlight the row or trigger navigation to a detail page. Row numbers are 0-based (first row is 0). Useful when clicking a row performs an action like opening a form or showing details.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>row_number</code> (int): 0-based row index (first row = 0)</li> <li><code>column_name</code> (str): Any column name in the table (used to locate the table)</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If table or row not found or not clickable within timeout</li> </ul> <p>Returns: None</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;&lt;th abbr=\"Name\" scope=\"col\"&gt;Name&lt;/th&gt;&lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr data-dnd-name=\"row 1\"&gt;&lt;td&gt;John Doe&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr data-dnd-name=\"row 2\"&gt;&lt;td&gt;Jane Smith&lt;/td&gt;&lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TableUtils import TableUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nTableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, 0, \"Name\")\n</code></pre></p>"},{"location":"api/table-utils/#findcomponentfromtablecell","title":"findComponentFromTableCell","text":"<p>Find an interactive element inside a specific table cell.</p> <p>Use this when you need to interact with buttons, links, inputs, or other components within a table cell. Locates the cell by row number (0-based) and column name, then returns the first interactive component inside that cell. Essential for clicking action buttons in table rows.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>row_number</code> (int): 0-based row index (first row = 0)</li> <li><code>column_name</code> (str): Exact column name where the component is located</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If table, row, or component not found or not clickable within timeout</li> </ul> <p>Returns: WebElement representing the component in the cell</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th abbr=\"Name\" scope=\"col\"&gt;Name&lt;/th&gt;\n      &lt;th abbr=\"Actions\" scope=\"col\"&gt;Actions&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr data-dnd-name=\"row 1\"&gt;\n      &lt;td&gt;John Doe&lt;/td&gt;\n      &lt;td&gt;&lt;button&gt;Edit&lt;/button&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TableUtils import TableUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nedit_button = TableUtils.findComponentFromTableCell(wait, 0, \"Actions\")\nedit_button.click()\n</code></pre></p>"},{"location":"api/table-utils/#findcomponentbycolumnnameandrownumber","title":"findComponentByColumnNameAndRowNumber","text":"<p>Find an interactive element in a table cell using column and row coordinates.</p> <p>Use this as an alternative to findComponentFromTableCell when you need more control over element discovery. This method uses a different internal lookup strategy that may work better with certain table structures. Returns the clickable component at the specified cell location.</p> <p>Args:</p> <ul> <li><code>wait</code> (WebDriverWait): WebDriverWait instance with configured timeout</li> <li><code>row_number</code> (int): 0-based row index (first row = 0)</li> <li><code>column_name</code> (str): Exact column name (from abbr attribute)</li> </ul> <p>Raises:</p> <ul> <li><code>TimeoutException</code>: If table, row, column, or component not found within timeout</li> </ul> <p>Returns: WebElement representing the component in the cell</p> <p>Examples:</p> <p>HTML: <pre><code>&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th abbr=\"Employee ID\" id=\"col_0\" scope=\"col\"&gt;ID&lt;/th&gt;\n      &lt;th abbr=\"Status\" id=\"col_1\" scope=\"col\"&gt;Status&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr data-dnd-name=\"row 1\"&gt;\n      &lt;td&gt;001&lt;/td&gt;\n      &lt;td&gt;&lt;span class=\"status-badge\"&gt;Active&lt;/span&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre></p> <p>Python: <pre><code>from robo_appian.components.TableUtils import TableUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nstatus_badge = TableUtils.findComponentByColumnNameAndRowNumber(wait, 0, \"Status\")\nprint(f\"Status: {status_badge.text}\")\n</code></pre></p>"},{"location":"examples/forms/","title":"Form Automation","text":"<p>Fill and submit a typical Appian form with text, dropdown, date, and search controls.</p>"},{"location":"examples/forms/#basic-form-fill","title":"Basic Form Fill","text":"<pre><code>from robo_appian.components import InputUtils, DropdownUtils, DateUtils, SearchDropdownUtils, ButtonUtils\n\n# Text fields\nInputUtils.setValueByLabelText(wait, \"First Name\", \"Ada\")\nInputUtils.setValueByLabelText(wait, \"Last Name\", \"Lovelace\")\nInputUtils.setValueByPlaceholderText(wait, \"Enter email\", \"ada@example.com\")\n\n# Dropdowns\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Status\", \"Active\")\nDropdownUtils.selectDropdownValueByPartialLabelText(wait, \"Country\", \"United States\")\n\n# Date picker\nDateUtils.setValueByLabelText(wait, \"Start Date\", \"01/01/2025\")\n\n# Search dropdown\nSearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Manager\", \"Grace Hopper\")\n\n# Submit\nButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre>"},{"location":"examples/forms/#multi-step-form-with-validation","title":"Multi-Step Form with Validation","text":"<pre><code>from robo_appian.components import InputUtils, LabelUtils, ButtonUtils\n\n# Fill first section\nInputUtils.setValueByLabelText(wait, \"Project Name\", \"Migration Project\")\nInputUtils.setValueByLabelText(wait, \"Budget\", \"50000\")\n\n# Click Next\nButtonUtils.clickByLabelText(wait, \"Next\")\n\n# Verify moved to next step\nLabelUtils.isLabelExists(wait, \"Step 2: Team Assignment\")\n\n# Fill second section\nSearchInputUtils.selectSearchDropdownByLabelText(wait, \"Project Lead\", \"John Smith\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Department\", \"Engineering\")\n\n# Submit final form\nButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre>"},{"location":"examples/forms/#conditional-form-fields","title":"Conditional Form Fields","text":"<pre><code>from robo_appian.components import DropdownUtils, InputUtils, LabelUtils\n\n# Select option that reveals additional fields\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Request Type\", \"New Equipment\")\n\n# Wait for conditional field to appear\nLabelUtils.isLabelExists(wait, \"Equipment Details\")\n\n# Fill conditional fields\nInputUtils.setValueByLabelText(wait, \"Equipment Type\", \"Laptop\")\nInputUtils.setValueByLabelText(wait, \"Justification\", \"Current device is 5 years old\")\n</code></pre>"},{"location":"examples/forms/#form-with-multiple-date-fields","title":"Form with Multiple Date Fields","text":"<pre><code>from robo_appian.components import DateUtils, ComponentUtils\n\n# Set multiple dates\nDateUtils.setValueByLabelText(wait, \"Start Date\", \"01/15/2025\")\nDateUtils.setValueByLabelText(wait, \"End Date\", \"03/31/2025\")\nDateUtils.setValueByLabelText(wait, \"Review Date\", \"02/15/2025\")\n\n# Use utility functions for dynamic dates\ntoday = ComponentUtils.today()\nyesterday = ComponentUtils.yesterday()\n\nDateUtils.setValueByLabelText(wait, \"Submission Date\", today)\nDateUtils.setValueByLabelText(wait, \"Last Modified\", yesterday)\n</code></pre>"},{"location":"examples/forms/#search-input-with-auto-complete","title":"Search Input with Auto-Complete","text":"<pre><code>from robo_appian.components import SearchInputUtils\n\n# Type and select from search input (not dropdown)\nSearchInputUtils.selectSearchDropdownByLabelText(wait, \"Employee\", \"Alice Johnson\")\n\n# Use partial matching for large result sets\nSearchInputUtils.selectSearchDropdownByPartialLabelText(wait, \"Department\", \"Engineer\")\n</code></pre>"},{"location":"examples/forms/#handling-read-only-fields","title":"Handling Read-Only Fields","text":"<pre><code>from robo_appian.components import DropdownUtils, InputUtils, LabelUtils\n\n# Verify field is read-only before attempting to edit\nis_readonly = DropdownUtils.checkReadOnlyStatusByLabelText(wait, \"Approval Status\")\n\nif not is_readonly:\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Approval Status\", \"Approved\")\nelse:\n    # Log or handle read-only state\n    print(\"Approval Status is read-only\")\n</code></pre> <p>Notes: - Labels must have <code>for</code> attributes for inputs/dates. If missing, create a targeted XPath and reuse <code>ComponentUtils</code> helpers. - Dropdown locators rely on <code>aria-controls</code>; if custom widgets differ, inspect DOM to align the pattern. - Use <code>LabelUtils.isLabelExists()</code> to verify section headers or conditional fields before interacting.</p>"},{"location":"examples/login/","title":"Login Flow","text":"<p>A simple login automation using label-based selectors.</p>"},{"location":"examples/login/#basic-login","title":"Basic Login","text":"<pre><code>from selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom robo_appian.components import InputUtils, ButtonUtils\n\nAPP_URL = \"https://your-appian.example.com\"\n\nwith webdriver.Chrome() as driver:\n    wait = WebDriverWait(driver, 10)\n    driver.get(APP_URL)\n\n    InputUtils.setValueByLabelText(wait, \"Username\", \"demo_user\")\n    InputUtils.setValueByLabelText(wait, \"Password\", \"SuperSecret!\")\n    ButtonUtils.clickByLabelText(wait, \"Sign In\")\n</code></pre>"},{"location":"examples/login/#login-with-ssoidentity-provider","title":"Login with SSO/Identity Provider","text":"<pre><code>from robo_appian.components import ButtonUtils, InputUtils\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Click SSO identity provider button\nButtonUtils.clickByLabelText(wait, \"Sign in with Azure AD\")\n\n# Wait for redirect to identity provider\nInputUtils.setValueByLabelText(wait, \"Email\", \"user@company.com\")\nButtonUtils.clickByLabelText(wait, \"Next\")\n\n# Enter password on IDP page\nInputUtils.setValueByLabelText(wait, \"Password\", \"SecurePassword123!\")\nButtonUtils.clickByLabelText(wait, \"Sign in\")\n</code></pre>"},{"location":"examples/login/#login-with-dynamic-labels","title":"Login with Dynamic Labels","text":"<p>When labels include dynamic text like environment names:</p> <pre><code>from robo_appian.components import InputUtils, ButtonUtils\n\n# Use partial label matching for dynamic labels\nInputUtils.setValueByPartialLabelText(wait, \"Username\", \"demo_user\")\nInputUtils.setValueByPartialLabelText(wait, \"Password\", \"SuperSecret!\")\nButtonUtils.clickByPartialLabelText(wait, \"Sign In\")\n</code></pre>"},{"location":"examples/login/#verify-successful-login","title":"Verify Successful Login","text":"<pre><code>from robo_appian.components import LabelUtils\n\n# Verify user logged in by checking for welcome message\nLabelUtils.isLabelExists(wait, \"Welcome, John Doe\")\n\n# Or verify a dashboard element is present\nLabelUtils.isLabelExists(wait, \"My Tasks\")\n</code></pre> <p>Tips: - Use exact labels when stable; switch to partial label methods if the UI appends text (e.g., \"Username (prod)\"). - For SSO/IDP flows, wait for visibility of the identity provider button and click via <code>ButtonUtils.clickByLabelText</code>. - Add explicit waits after login to ensure the next page loads before continuing.</p>"},{"location":"examples/tables/","title":"Table Operations","text":"<p>Interact with Appian grid components by column name and row index (0-based in APIs).</p>"},{"location":"examples/tables/#basic-table-interactions","title":"Basic Table Interactions","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils\n\n# Click the first row where column \"Employee ID\" is present\nTableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, 0, \"Employee ID\")\n\n# Click a button inside a cell\ncell_component = TableUtils.findComponentFromTableCell(wait, 0, \"Actions\")\nButtonUtils.clickByLabelText(wait, \"Edit\")\n\n# Read a component from a specific column/row\nstatus_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, 1, \"Status\")\ntext = status_cell.text\n</code></pre>"},{"location":"examples/tables/#count-and-iterate-through-rows","title":"Count and Iterate Through Rows","text":"<pre><code>from robo_appian.components import TableUtils\n\n# Find table and get row count\ntable = TableUtils.findTableByColumnName(wait, \"Employee ID\")\nrow_count = TableUtils.rowCount(table)\n\nprint(f\"Table has {row_count} rows\")\n\n# Iterate through all rows\nfor row_index in range(row_count):\n    # Get cell value from each row\n    name_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Name\")\n    print(f\"Row {row_index}: {name_cell.text}\")\n</code></pre>"},{"location":"examples/tables/#find-and-click-specific-row","title":"Find and Click Specific Row","text":"<pre><code>from robo_appian.components import TableUtils\n\n# Find table\ntable = TableUtils.findTableByColumnName(wait, \"Status\")\nrow_count = TableUtils.rowCount(table)\n\n# Search for row with specific value\nfor row_index in range(row_count):\n    status = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Status\")\n\n    if status.text == \"Pending\":\n        # Click action button in this row\n        TableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, row_index, \"Status\")\n        break\n</code></pre>"},{"location":"examples/tables/#extract-all-data-from-table","title":"Extract All Data from Table","text":"<pre><code>from robo_appian.components import TableUtils\n\n# Get table reference\ntable = TableUtils.findTableByColumnName(wait, \"Employee ID\")\nrow_count = TableUtils.rowCount(table)\n\n# Define columns to extract\ncolumns = [\"Employee ID\", \"Name\", \"Department\", \"Status\"]\n\n# Extract all data\ntable_data = []\nfor row_index in range(row_count):\n    row_data = {}\n    for column in columns:\n        cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, column)\n        row_data[column] = cell.text\n    table_data.append(row_data)\n\n# Use extracted data\nfor row in table_data:\n    print(f\"{row['Name']} - {row['Department']} - {row['Status']}\")\n</code></pre>"},{"location":"examples/tables/#click-button-in-specific-cell","title":"Click Button in Specific Cell","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils\n\n# Find and click the Edit button in row 2, Actions column\nedit_button = TableUtils.findComponentFromTableCell(wait, 2, \"Actions\")\nComponentUtils.click(wait, edit_button)\n\n# Or if the button has a label, click by label\nTableUtils.findComponentFromTableCell(wait, 2, \"Actions\")\nButtonUtils.clickByLabelText(wait, \"Delete\")\n</code></pre>"},{"location":"examples/tables/#verify-table-contents","title":"Verify Table Contents","text":"<pre><code>from robo_appian.components import TableUtils\n\n# Find specific employee row\ntable = TableUtils.findTableByColumnName(wait, \"Name\")\nrow_count = TableUtils.rowCount(table)\n\n# Verify specific employee exists\nemployee_found = False\nfor row_index in range(row_count):\n    name_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Name\")\n    if name_cell.text == \"John Doe\":\n        employee_found = True\n\n        # Verify other columns for this employee\n        status = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Status\")\n        assert status.text == \"Active\", f\"Expected Active but got {status.text}\"\n        break\n\nassert employee_found, \"Employee 'John Doe' not found in table\"\n</code></pre>"},{"location":"examples/tables/#handle-paginated-tables","title":"Handle Paginated Tables","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils, LabelUtils\n\n# Process all pages\nwhile True:\n    # Process current page\n    table = TableUtils.findTableByColumnName(wait, \"Employee ID\")\n    row_count = TableUtils.rowCount(table)\n\n    for row_index in range(row_count):\n        # Process each row\n        cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Name\")\n        print(f\"Processing: {cell.text}\")\n\n    # Check if \"Next\" button exists and is enabled\n    try:\n        ButtonUtils.clickByLabelText(wait, \"Next\")\n    except:\n        # No more pages\n        break\n</code></pre> <p>Guidelines: - Column detection uses header <code>abbr</code> attributes; ensure your column names match those values. - Public APIs use 0-based row numbers; the helper converts to Appian's 1-based row identifiers. - Empty grid rows are skipped via <code>data-empty-grid-message</code> checks. - For large tables, consider extracting data in batches to avoid memory issues.</p>"},{"location":"examples/workflows/","title":"Complex Workflows","text":"<p>Drive multi-step flows using component utilities for clear, maintainable test code.</p>"},{"location":"examples/workflows/#approval-workflow","title":"Approval Workflow","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils, InputUtils, LabelUtils\n\n# Navigate to pending approvals\nButtonUtils.clickByLabelText(wait, \"My Approvals\")\n\n# Find table of pending requests\ntable = TableUtils.findTableByColumnName(wait, \"Request ID\")\nrow_count = TableUtils.rowCount(table)\n\n# Approve specific request\nfor row_index in range(row_count):\n    request_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Request Title\")\n\n    if \"Laptop\" in request_cell.text:\n        # Click review button\n        TableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, row_index, \"Request ID\")\n\n        # Add approval comments\n        InputUtils.setValueByLabelText(wait, \"Comments\", \"Approved for Q1 budget\")\n\n        # Approve\n        ButtonUtils.clickByLabelText(wait, \"Approve\")\n        break\n</code></pre>"},{"location":"examples/workflows/#multi-page-workflow-with-validation","title":"Multi-Page Workflow with Validation","text":"<pre><code>from robo_appian.components import InputUtils, DropdownUtils, DateUtils, ButtonUtils, LabelUtils\n\n# Page 1: Basic Information\nInputUtils.setValueByLabelText(wait, \"Project Name\", \"Cloud Migration\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Project Type\", \"Infrastructure\")\nDateUtils.setValueByLabelText(wait, \"Start Date\", \"03/01/2025\")\n\nButtonUtils.clickByLabelText(wait, \"Next\")\n\n# Verify page 2 loaded\nLabelUtils.isLabelExists(wait, \"Budget Details\")\n\n# Page 2: Budget\nInputUtils.setValueByLabelText(wait, \"Estimated Cost\", \"150000\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Cost Center\", \"IT-Operations\")\n\nButtonUtils.clickByLabelText(wait, \"Next\")\n\n# Verify page 3 loaded\nLabelUtils.isLabelExists(wait, \"Team Assignment\")\n\n# Page 3: Team\nSearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Project Manager\", \"Alice Brown\")\nSearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Technical Lead\", \"Bob Wilson\")\n\n# Review and Submit\nButtonUtils.clickByLabelText(wait, \"Review\")\nLabelUtils.isLabelExists(wait, \"Confirmation\")\nButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre>"},{"location":"examples/workflows/#conditional-workflow-paths","title":"Conditional Workflow Paths","text":"<pre><code>from robo_appian.components import DropdownUtils, InputUtils, ButtonUtils, LabelUtils\n\n# Select request type\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Request Type\", \"Equipment\")\n\n# Path diverges based on selection\ntry:\n    # Check if equipment-specific fields appear\n    LabelUtils.isLabelExists(wait, \"Equipment Details\")\n\n    # Fill equipment-specific form\n    InputUtils.setValueByLabelText(wait, \"Item Description\", \"MacBook Pro\")\n    InputUtils.setValueByLabelText(wait, \"Quantity\", \"1\")\n    DropdownUtils.selectDropdownValueByLabelText(wait, \"Urgency\", \"Standard\")\n\nexcept:\n    # Different path for other request types\n    InputUtils.setValueByLabelText(wait, \"Description\", \"General request\")\n\n# Common final step\nButtonUtils.clickByLabelText(wait, \"Submit\")\n</code></pre>"},{"location":"examples/workflows/#retry-workflow-with-error-handling","title":"Retry Workflow with Error Handling","text":"<pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components import ButtonUtils, InputUtils, LabelUtils\n\ndef submit_form():\n    \"\"\"Submit form with retry logic\"\"\"\n    InputUtils.setValueByLabelText(wait, \"Title\", \"Test Request\")\n    ButtonUtils.clickByLabelText(wait, \"Submit\")\n\n    # Verify success\n    LabelUtils.isLabelExists(wait, \"Request Submitted Successfully\")\n\n# Retry up to 3 times on timeout\nRoboUtils.retry_on_timeout(submit_form, max_retries=3, name=\"Submit Form\")\n</code></pre>"},{"location":"examples/workflows/#complete-end-to-end-workflow","title":"Complete End-to-End Workflow","text":"<pre><code>from robo_appian.components import TableUtils, ButtonUtils, LabelUtils, InputUtils, DropdownUtils, SearchDropdownUtils\n\n# Step 1: Create new request\nButtonUtils.clickByLabelText(wait, \"New Request\")\n\n# Fill request form using component utilities\nInputUtils.setValueByLabelText(wait, \"Request Title\", \"Software License\")\nInputUtils.setValueByLabelText(wait, \"Justification\", \"Required for project\")\nDropdownUtils.selectDropdownValueByLabelText(wait, \"Category\", \"Software\")\nSearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Approver\", \"Manager Name\")\nButtonUtils.clickByLabelText(wait, \"Submit\")\n\n# Step 2: Verify request appears in tracking\nLabelUtils.isLabelExists(wait, \"Request Submitted\")\nButtonUtils.clickByLabelText(wait, \"View My Requests\")\n\n# Step 3: Find submitted request in table\ntable = TableUtils.findTableByColumnName(wait, \"Title\")\nrow_count = TableUtils.rowCount(table)\n\nrequest_found = False\nfor row_index in range(row_count):\n    title_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Title\")\n\n    if title_cell.text == \"Software License\":\n        # Verify status\n        status_cell = TableUtils.findComponentByColumnNameAndRowNumber(wait, row_index, \"Status\")\n        assert status_cell.text == \"Pending\", f\"Expected Pending but got {status_cell.text}\"\n        request_found = True\n        break\n\nassert request_found, \"Submitted request not found in tracking table\"\n</code></pre>"},{"location":"examples/workflows/#tab-navigation-workflow","title":"Tab Navigation Workflow","text":"<pre><code>from robo_appian.components import TabUtils, TableUtils, ButtonUtils\n\n# Navigate to different workflow stages using tabs\nTabUtils.selectTabByLabelText(wait, \"Active Requests\")\n\n# Process active requests\ntable = TableUtils.findTableByColumnName(wait, \"Request ID\")\nrow_count = TableUtils.rowCount(table)\nprint(f\"Active requests: {row_count}\")\n\n# Switch to completed tab\nTabUtils.selectTabByLabelText(wait, \"Completed\")\n\n# Verify tab is active\nis_selected = TabUtils.checkTabSelectedByLabelText(wait, \"Completed\")\nassert is_selected, \"Completed tab not selected\"\n\n# Process completed requests\ntable = TableUtils.findTableByColumnName(wait, \"Request ID\")\ncompleted_count = TableUtils.rowCount(table)\nprint(f\"Completed requests: {completed_count}\")\n</code></pre> <p>Tips: - Use specific component utilities for clear, readable test code. - Wrap long flows with <code>RoboUtils.retry_on_timeout</code> for known flaky spots instead of raising global timeouts. - Use <code>LabelUtils.isLabelExists()</code> to verify each page/step loaded before proceeding. - For debugging, add print statements or logging between major workflow steps.</p>"},{"location":"frameworks/pytest/","title":"pytest Integration","text":"<p>Use fixtures to share the browser and <code>WebDriverWait</code> across tests.</p>"},{"location":"frameworks/pytest/#sample-conftestpy","title":"Sample <code>conftest.py</code>","text":"<pre><code>import pytest\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n@pytest.fixture(scope=\"session\")\ndef driver():\n    driver = webdriver.Chrome()\n    driver.maximize_window()\n    yield driver\n    driver.quit()\n\n@pytest.fixture\ndef wait(driver):\n    return WebDriverWait(driver, 10)\n</code></pre>"},{"location":"frameworks/pytest/#example-test","title":"Example test","text":"<pre><code>from robo_appian.components import InputUtils, ButtonUtils\n\n\ndef test_login(wait):\n    driver = wait._driver\n    driver.get(\"https://your-appian.example.com\")\n\n    InputUtils.setValueByLabelText(wait, \"Username\", \"demo_user\")\n    InputUtils.setValueByLabelText(wait, \"Password\", \"SuperSecret!\")\n    ButtonUtils.clickByLabelText(wait, \"Sign In\")\n</code></pre>"},{"location":"frameworks/pytest/#tips","title":"Tips","text":"<ul> <li>Keep fixtures small; prefer one <code>wait</code> fixture that wraps a shared driver.</li> <li>If tests need isolation, change driver fixture scope to <code>function</code>.</li> <li>Add markers for slow/UI tests and run with <code>pytest -m ui</code> in CI.</li> </ul>"},{"location":"frameworks/unittest/","title":"unittest Integration","text":"<p>Use <code>setUp</code>/<code>tearDown</code> to manage the browser and <code>WebDriverWait</code>.</p> <pre><code>import unittest\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom robo_appian.components import InputUtils, ButtonUtils\n\nclass LoginTest(unittest.TestCase):\n    def setUp(self):\n        self.driver = webdriver.Chrome()\n        self.wait = WebDriverWait(self.driver, 10)\n\n    def tearDown(self):\n        self.driver.quit()\n\n    def test_login(self):\n        self.driver.get(\"https://your-appian.example.com\")\n        InputUtils.setValueByLabelText(self.wait, \"Username\", \"demo_user\")\n        InputUtils.setValueByLabelText(self.wait, \"Password\", \"SuperSecret!\")\n        ButtonUtils.clickByLabelText(self.wait, \"Sign In\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>Adjust the timeout or add helpers like <code>RoboUtils.retry_on_timeout</code> inside tests if certain steps are flaky.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Follow these steps to install Robo Appian and its prerequisites.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>A working Selenium WebDriver for your browser (e.g., ChromeDriver, GeckoDriver) on PATH</li> <li>pip and (optionally) Poetry for dev work</li> </ul>"},{"location":"getting-started/installation/#install-the-package","title":"Install the package","text":"<p>Using pip: <pre><code>pip install robo_appian\n</code></pre></p> <p>Using Poetry: <pre><code>poetry add robo_appian\n</code></pre></p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify installation","text":"<pre><code>python -c \"import robo_appian; print(robo_appian.__version__)\"\n</code></pre> <p>If you see a version string, installation was successful. If WebDriver fails to start, confirm the driver binary (ChromeDriver, GeckoDriver, etc.) matches your browser version and is on PATH.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get started with Robo Appian in minutes.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<pre><code>pip install robo_appian\n</code></pre>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<pre><code>from selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom robo_appian.components import InputUtils, ButtonUtils\n\n# Setup\ndriver = webdriver.Chrome()\nwait = WebDriverWait(driver, 10)\ndriver.get(\"https://your-appian.example.com\")\n\n# Interact by label\nInputUtils.setValueByLabelText(wait, \"Username\", \"demo_user\")\nInputUtils.setValueByLabelText(wait, \"Password\", \"secret\")\nButtonUtils.clickByLabelText(wait, \"Sign In\")\n\ndriver.quit()\n</code></pre> <p>Key points: - Pass <code>wait</code> first to all methods - Components located by visible labels (not IDs) - Automatic waiting and safe click handling</p>"},{"location":"getting-started/quick-start/#with-pytest","title":"With Pytest","text":"<pre><code># conftest.py\nimport pytest\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n@pytest.fixture\ndef wait():\n    driver = webdriver.Chrome()\n    yield WebDriverWait(driver, 10)\n    driver.quit()\n\n# test_login.py\ndef test_login(wait):\n    wait._driver.get(\"https://your-appian.example.com\")\n    InputUtils.setValueByLabelText(wait, \"Username\", \"demo\")\n    ButtonUtils.clickByLabelText(wait, \"Sign In\")\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Core Components - Available utilities</li> <li>Examples - Real-world scenarios</li> <li>API Reference - Full documentation</li> </ul>"},{"location":"user-guide/advanced/","title":"Advanced Features","text":""},{"location":"user-guide/advanced/#retrying-flaky-actions","title":"Retrying flaky actions","text":"<p>Use <code>RoboUtils.retry_on_timeout(op, max_retries, name)</code> to wrap waits or actions that may intermittently time out.</p> <pre><code>from robo_appian.utils.RoboUtils import RoboUtils\nfrom robo_appian.components import ButtonUtils\n\nRoboUtils.retry_on_timeout(\n    lambda: ButtonUtils.clickByLabelText(wait, \"Submit\"),\n    max_retries=3,\n    operation_name=\"click submit\",\n)\n</code></pre>"},{"location":"user-guide/advanced/#safe-clicking-everywhere","title":"Safe clicking everywhere","text":"<p>All click paths funnel through <code>ComponentUtils.click(wait, element)</code>, which waits for clickability and uses ActionChains to bypass overlay/animation issues. Use it for any custom elements you locate yourself.</p>"},{"location":"user-guide/advanced/#version-helper","title":"Version helper","text":"<p><code>ComponentUtils.get_version()</code> reads <code>pyproject.toml</code> from repo root\u2014useful for diagnostics and reporting.</p>"},{"location":"user-guide/best-practices/","title":"Best Practices","text":"<ul> <li>Always pass <code>wait</code> first: Public APIs accept <code>WebDriverWait</code> then derive <code>driver</code> via <code>wait._driver</code>. Keep custom helpers consistent.</li> <li>Normalize labels: Use exact label APIs when possible; fall back to partial label variants when labels carry dynamic counts/suffixes.</li> <li>Keep NBSP handling: Locators rely on <code>translate(., \"\\u00a0\", \" \")</code> to normalize Appian whitespace\u2014preserve this in new XPaths.</li> <li>Use safe click: Prefer <code>ComponentUtils.click</code> over <code>element.click()</code> to handle overlays/animations.</li> <li>Respect table indexing: Public table APIs take 0-based rows; convert to 1-based only inside helpers.</li> <li>Retry intentionally: Wrap only flaky waits/actions with <code>RoboUtils.retry_on_timeout</code>; avoid masking real failures.</li> <li>Keep APIs deterministic: Avoid global state; ensure utilities are importable and side-effect free for external tests.</li> </ul>"},{"location":"user-guide/components/","title":"Core Components","text":"<p>This guide highlights how each <code>*Utils</code> class locates and interacts with Appian components. All methods accept <code>wait: WebDriverWait</code> first.</p>"},{"location":"user-guide/components/#inputs","title":"Inputs","text":"<ul> <li>Exact label: <code>InputUtils.setValueByLabelText(wait, \"Username\", \"alice\")</code></li> <li>Partial label: <code>InputUtils.setValueByPartialLabelText(wait, \"User\", \"alice\")</code></li> <li>By placeholder: <code>InputUtils.setValueByPlaceholderText(wait, \"Enter email\", \"alice@example.com\")</code></li> <li>Behavior: waits for clickability, moves to element, clears, then types. Labels must have a <code>for</code> attribute pointing to the input.</li> </ul>"},{"location":"user-guide/components/#buttons","title":"Buttons","text":"<ul> <li>Exact label: <code>ButtonUtils.clickByLabelText(wait, \"Submit\")</code></li> <li>Partial label: <code>ButtonUtils.clickByPartialLabelText(wait, \"Save\")</code></li> <li>By id: <code>ButtonUtils.clickById(wait, \"save_btn\")</code></li> <li>Behavior: waits for <code>element_to_be_clickable</code>, uses <code>ComponentUtils.click</code> (ActionChains) to handle overlays.</li> </ul>"},{"location":"user-guide/components/#dropdowns","title":"Dropdowns","text":"<ul> <li>Select: <code>DropdownUtils.selectDropdownValueByLabelText(wait, \"Status\", \"Active\")</code></li> <li>Partial label: <code>selectDropdownValueByPartialLabelText(...)</code></li> <li>Checks: <code>checkEditableStatusByLabelText</code>, <code>checkReadOnlyStatusByLabelText</code>, <code>waitForDropdownToBeEnabled</code></li> <li>Locators: label \u279c nearest combobox (<code>role=\"combobox\"</code>), uses <code>aria-controls</code> to find the option list.</li> </ul>"},{"location":"user-guide/components/#search-dropdowns","title":"Search Dropdowns","text":"<ul> <li>Select: <code>SearchDropdownUtils.selectSearchDropdownValueByLabelText(wait, \"Employee\", \"John Doe\")</code></li> <li>Pattern: combobox ID with <code>_value</code> suffix \u279c search input <code>*_searchInput</code> \u279c options list <code>*_list</code>.</li> </ul>"},{"location":"user-guide/components/#search-inputs","title":"Search Inputs","text":"<ul> <li>Select: <code>SearchInputUtils.selectSearchDropdownByLabelText(wait, \"City\", \"Boston\")</code></li> <li>Pattern: label \u279c <code>_searchInput</code> input \u279c <code>_list</code> options.</li> </ul>"},{"location":"user-guide/components/#dates","title":"Dates","text":"<ul> <li>Set: <code>DateUtils.setValueByLabelText(wait, \"Start Date\", \"01/01/2025\")</code></li> <li>Clears and types the date string; relies on label <code>for</code> attribute.</li> </ul>"},{"location":"user-guide/components/#tabs-links-labels","title":"Tabs, Links, Labels","text":"<ul> <li>Tabs: <code>TabUtils.selectTabByLabelText(wait, \"Details\")</code></li> <li>Links: <code>LinkUtils.click(wait, \"View more\")</code></li> <li>Labels: <code>LabelUtils.isLabelExists(wait, \"Important notice\")</code></li> </ul>"},{"location":"user-guide/components/#tables","title":"Tables","text":"<ul> <li>Find table: <code>TableUtils.findTableByColumnName(wait, \"Employee ID\")</code></li> <li>Click row by column + index: <code>TableUtils.selectRowFromTableByColumnNameAndRowNumber(wait, 0, \"Employee ID\")</code></li> <li>Find cell component: <code>TableUtils.findComponentFromTableCell(wait, 1, \"Status\")</code></li> <li>Column resolution uses header <code>abbr</code> plus header class/id parsing. Public APIs use 0-based <code>rowNumber</code>; internally converted to Appian's 1-based rows.</li> </ul> <p>For detailed signatures and parameters, see the API Reference.</p>"},{"location":"user-guide/error-handling/","title":"Error Handling","text":""},{"location":"user-guide/error-handling/#common-failures","title":"Common failures","text":"<ul> <li>TimeoutException: Element not found/visible/clickable within <code>WebDriverWait</code>. Verify labels match exactly and the component is not hidden or disabled.</li> <li>ValueError: Label missing a <code>for</code> attribute (inputs/dates) or combobox missing <code>aria-controls</code>. Inspect the page markup and adjust the locator.</li> <li>StaleElementReference: DOM refreshed between lookup and interaction. Re-query via the util rather than reusing stale elements.</li> </ul>"},{"location":"user-guide/error-handling/#debug-tips","title":"Debug tips","text":"<ul> <li>Increase wait duration temporarily during investigation.</li> <li>Use <code>ComponentUtils.waitForComponentToBeVisibleByXpath</code> with a narrowed XPath to confirm visibility.</li> <li>For dropdowns/search inputs, check the derived IDs: <code>*_searchInput</code>, <code>*_list</code>, <code>*_value</code>.</li> <li>For tables, confirm the header <code>abbr</code> matches the column name you pass.</li> </ul>"},{"location":"user-guide/error-handling/#recovery-patterns","title":"Recovery patterns","text":"<ul> <li>Wrap flaky operations with <code>RoboUtils.retry_on_timeout</code> to reattempt timeouts.</li> <li>For dependent steps, wait for negative conditions (e.g., <code>waitForComponentNotToBeVisibleByXpath</code>) before proceeding to avoid overlay issues.</li> </ul>"},{"location":"user-guide/overview/","title":"Architecture Overview","text":"<p>Robo Appian wraps Selenium with Appian-specific patterns, making tests business-readable and maintainable.</p>"},{"location":"user-guide/overview/#core-design-principles","title":"Core Design Principles","text":""},{"location":"user-guide/overview/#wait-first-pattern","title":"Wait-First Pattern","text":"<p>Every robo_appian method accepts <code>WebDriverWait</code> as the first parameter. This ensures:</p> <ul> <li>Consistent timeout behavior across all interactions</li> <li>Automatic waiting for elements to be present, visible, and interactable</li> <li>No need for manual <code>time.sleep()</code> or custom wait logic</li> <li>Centralized timeout configuration (set once when creating <code>WebDriverWait</code>)</li> </ul> <pre><code>from selenium.webdriver.support.ui import WebDriverWait\n\n# Configure wait once\nwait = WebDriverWait(driver, 10)\n\n# All methods use this wait automatically\nInputUtils.setValueByLabelText(wait, \"Username\", \"test_user\")\nButtonUtils.clickByLabelText(wait, \"Sign In\")\n</code></pre>"},{"location":"user-guide/overview/#label-driven-selectors","title":"Label-Driven Selectors","text":"<p>Robo Appian locates elements by their visible labels\u2014the text users actually see. This is powered by:</p> <ul> <li>Label-to-input associations: HTML <code>&lt;label for=\"...\"&gt;</code> attributes that connect labels to form fields</li> <li>ARIA attributes: <code>aria-label</code>, <code>aria-labelledby</code>, and <code>aria-controls</code> for complex components</li> <li>Header abbreviations: Table columns identified by <code>abbr</code> attributes on headers</li> <li>Normalized text matching: Automatic handling of whitespace and non-breaking spaces (NBSP)</li> </ul>"},{"location":"user-guide/overview/#safe-click-operations","title":"Safe Click Operations","text":"<p>Direct <code>element.click()</code> calls fail frequently due to:</p> <ul> <li>Elements covered by overlays or animations</li> <li>Timing issues during page transitions</li> <li>Stale element references after DOM updates</li> </ul> <p>Robo Appian's <code>ComponentUtils.click()</code> method combines:</p> <ul> <li>Explicit wait: Ensures element is clickable before interaction</li> <li>ActionChains: Moves mouse to element center and performs reliable click.</li> <li>Error context: Provides clear diagnostics when clicks fail</li> </ul> <p>All robo_appian click operations use this safe pattern internally.</p>"},{"location":"user-guide/overview/#library-structure","title":"Library Structure","text":""},{"location":"user-guide/overview/#component-utilities","title":"Component Utilities","text":"<p>Located in <code>robo_appian/components</code>, these static utility classes handle specific Appian UI elements:</p> <ul> <li>ButtonUtils: Click buttons by label text (exact or partial matching)</li> <li>InputUtils: Fill text inputs by label or placeholder</li> <li>DateUtils: Set date picker values by label</li> <li>DropdownUtils: Select from standard dropdowns (aria-controls pattern)</li> <li>SearchDropdownUtils: Type and select from filterable dropdowns</li> <li>SearchInputUtils: Interact with searchable input fields</li> <li>TableUtils: Find tables, count rows, click cells, extract data</li> <li>TabUtils: Navigate between tab panels</li> <li>LabelUtils: Verify label existence and visibility</li> <li>LinkUtils: Click links by visible text</li> </ul> <p>Each utility provides multiple methods for common variations (exact label, partial label, by ID, by placeholder, etc.).</p>"},{"location":"user-guide/overview/#shared-utilities","title":"Shared Utilities","text":"<p>Located in <code>robo_appian/utils</code>, these provide foundational capabilities:</p> <ul> <li>ComponentUtils: Core element finding, waiting, clicking, and version utilities</li> <li>RoboUtils: Retry logic for flaky operations (<code>retry_on_timeout</code>)</li> <li>BrowserUtils: Browser management and configuration helpers</li> </ul>"},{"location":"user-guide/overview/#key-patterns","title":"Key Patterns","text":""},{"location":"user-guide/overview/#static-method-design","title":"Static Method Design","text":"<p>All component utilities are designed as static classes. This approach:</p> <ul> <li>Eliminates unnecessary object instantiation</li> <li>Makes imports cleaner (<code>from robo_appian.components import InputUtils</code>)</li> <li>Signals that methods are stateless and side-effect free</li> <li>Follows Selenium's established patterns</li> </ul>"},{"location":"user-guide/overview/#table-interactions","title":"Table Interactions","text":"<p>Tables are particularly complex in Appian. TableUtils provides:</p> <ul> <li>Column identification: Uses <code>abbr</code> attribute on <code>&lt;th&gt;</code> elements</li> <li>Row indexing: Public APIs use 0-based indexing; internally converts to Appian's 1-based <code>data-dnd-name</code> attribute</li> <li>Cell navigation: Finds components within specific cells by column name + row number</li> <li>Data extraction: Reads text from cells for assertions</li> </ul>"},{"location":"user-guide/overview/#version-management","title":"Version Management","text":"<p><code>ComponentUtils.get_version()</code> reads the version from <code>pyproject.toml</code> at runtime, enabling:</p> <ul> <li>Dynamic version reporting in logs</li> <li>Version-aware debugging</li> <li>Compatibility checks in test setup</li> </ul>"},{"location":"user-guide/overview/#resilience-features","title":"Resilience Features","text":""},{"location":"user-guide/overview/#automatic-retries","title":"Automatic Retries","text":"<p><code>RoboUtils.retry_on_timeout()</code> wraps flaky operations:</p> <pre><code>def flaky_operation():\n    ButtonUtils.clickByLabelText(wait, \"Load More\")\n\nRoboUtils.retry_on_timeout(flaky_operation, max_retries=3, name=\"Load More Click\")\n</code></pre> <p>This handles:</p> <ul> <li>Temporary network delays</li> <li>Animation timing issues</li> <li>Sporadic stale element references</li> </ul>"},{"location":"user-guide/overview/#partial-label-matching","title":"Partial Label Matching","text":"<p>When Appian appends dynamic text to labels (e.g., \"Username (Production)\" vs \"Username (Test)\"), use partial matching:</p> <pre><code>InputUtils.setValueByPartialLabelText(wait, \"Username\", \"test_user\")\n</code></pre> <p>This matches any label containing \"Username\", making tests environment-agnostic.</p>"},{"location":"user-guide/overview/#when-to-use-robo-appian","title":"When to Use Robo Appian","text":"<p>Ideal for: - Appian UI regression and end-to-end testing - CI/CD automation pipelines - Data-driven test scenarios</p> <p>Not recommended for: - Non-Appian applications - API testing</p> <p>See Components for detailed usage patterns.</p>"}]}